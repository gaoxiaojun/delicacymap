// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "MapProtocol.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace ProtocolBuffer {

void protobuf_ShutdownFile_MapProtocol_2eproto() {
  delete Location::default_instance_;
  delete Route::default_instance_;
  delete Area::default_instance_;
  delete Time::default_instance_;
  delete Comment::default_instance_;
  delete Currency::default_instance_;
  delete Error::default_instance_;
  delete User::default_instance_;
  delete Restaurant::default_instance_;
  delete RestaurantList::default_instance_;
  delete CommentList::default_instance_;
  delete UserList::default_instance_;
  delete RestaurantType::default_instance_;
  delete Query::default_instance_;
  delete DMessage::default_instance_;
}

void protobuf_AddDesc_MapProtocol_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  Location::default_instance_ = new Location();
  Route::default_instance_ = new Route();
  Area::default_instance_ = new Area();
  Time::default_instance_ = new Time();
  Comment::default_instance_ = new Comment();
  Currency::default_instance_ = new Currency();
  Error::default_instance_ = new Error();
  User::default_instance_ = new User();
  Restaurant::default_instance_ = new Restaurant();
  RestaurantList::default_instance_ = new RestaurantList();
  CommentList::default_instance_ = new CommentList();
  UserList::default_instance_ = new UserList();
  RestaurantType::default_instance_ = new RestaurantType();
  Query::default_instance_ = new Query();
  DMessage::default_instance_ = new DMessage();
  Location::default_instance_->InitAsDefaultInstance();
  Route::default_instance_->InitAsDefaultInstance();
  Area::default_instance_->InitAsDefaultInstance();
  Time::default_instance_->InitAsDefaultInstance();
  Comment::default_instance_->InitAsDefaultInstance();
  Currency::default_instance_->InitAsDefaultInstance();
  Error::default_instance_->InitAsDefaultInstance();
  User::default_instance_->InitAsDefaultInstance();
  Restaurant::default_instance_->InitAsDefaultInstance();
  RestaurantList::default_instance_->InitAsDefaultInstance();
  CommentList::default_instance_->InitAsDefaultInstance();
  UserList::default_instance_->InitAsDefaultInstance();
  RestaurantType::default_instance_->InitAsDefaultInstance();
  Query::default_instance_->InitAsDefaultInstance();
  DMessage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_MapProtocol_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_MapProtocol_2eproto {
  StaticDescriptorInitializer_MapProtocol_2eproto() {
    protobuf_AddDesc_MapProtocol_2eproto();
  }
} static_descriptor_initializer_MapProtocol_2eproto_;

bool SystemMessageType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Location::kLatitudeFieldNumber;
const int Location::kLongitudeFieldNumber;
#endif  // !_MSC_VER

Location::Location()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Location::InitAsDefaultInstance() {
}

Location::Location(const Location& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Location::SharedCtor() {
  _cached_size_ = 0;
  latitude_ = 0;
  longitude_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Location::~Location() {
  SharedDtor();
}

void Location::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Location::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Location& Location::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Location* Location::default_instance_ = NULL;

Location* Location::New() const {
  return new Location;
}

void Location::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    latitude_ = 0;
    longitude_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Location::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double latitude = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &latitude_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_longitude;
        break;
      }
      
      // required double longitude = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_longitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &longitude_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Location::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double latitude = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->latitude(), output);
  }
  
  // required double longitude = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->longitude(), output);
  }
  
}

int Location::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double latitude = 1;
    if (has_latitude()) {
      total_size += 1 + 8;
    }
    
    // required double longitude = 2;
    if (has_longitude()) {
      total_size += 1 + 8;
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Location::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Location*>(&from));
}

void Location::MergeFrom(const Location& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_latitude(from.latitude());
    }
    if (from._has_bit(1)) {
      set_longitude(from.longitude());
    }
  }
}

void Location::CopyFrom(const Location& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Location::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Location::Swap(Location* other) {
  if (other != this) {
    std::swap(latitude_, other->latitude_);
    std::swap(longitude_, other->longitude_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Location::GetTypeName() const {
  return "ProtocolBuffer.Location";
}


// ===================================================================

#ifndef _MSC_VER
const int Route::kWayPointsFieldNumber;
#endif  // !_MSC_VER

Route::Route()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Route::InitAsDefaultInstance() {
}

Route::Route(const Route& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Route::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Route::~Route() {
  SharedDtor();
}

void Route::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Route::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Route& Route::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Route* Route::default_instance_ = NULL;

Route* Route::New() const {
  return new Route;
}

void Route::Clear() {
  waypoints_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Route::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ProtocolBuffer.Location WayPoints = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_WayPoints:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_waypoints()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_WayPoints;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Route::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ProtocolBuffer.Location WayPoints = 1;
  for (int i = 0; i < this->waypoints_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->waypoints(i), output);
  }
  
}

int Route::ByteSize() const {
  int total_size = 0;
  
  // repeated .ProtocolBuffer.Location WayPoints = 1;
  total_size += 1 * this->waypoints_size();
  for (int i = 0; i < this->waypoints_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->waypoints(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Route::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Route*>(&from));
}

void Route::MergeFrom(const Route& from) {
  GOOGLE_CHECK_NE(&from, this);
  waypoints_.MergeFrom(from.waypoints_);
}

void Route::CopyFrom(const Route& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Route::IsInitialized() const {
  
  for (int i = 0; i < waypoints_size(); i++) {
    if (!this->waypoints(i).IsInitialized()) return false;
  }
  return true;
}

void Route::Swap(Route* other) {
  if (other != this) {
    waypoints_.Swap(&other->waypoints_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Route::GetTypeName() const {
  return "ProtocolBuffer.Route";
}


// ===================================================================

#ifndef _MSC_VER
const int Area::kNortheastFieldNumber;
const int Area::kSouthwestFieldNumber;
#endif  // !_MSC_VER

Area::Area()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Area::InitAsDefaultInstance() {
  northeast_ = const_cast< ::ProtocolBuffer::Location*>(&::ProtocolBuffer::Location::default_instance());
  southwest_ = const_cast< ::ProtocolBuffer::Location*>(&::ProtocolBuffer::Location::default_instance());
}

Area::Area(const Area& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Area::SharedCtor() {
  _cached_size_ = 0;
  northeast_ = NULL;
  southwest_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Area::~Area() {
  SharedDtor();
}

void Area::SharedDtor() {
  if (this != default_instance_) {
    delete northeast_;
    delete southwest_;
  }
}

void Area::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Area& Area::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Area* Area::default_instance_ = NULL;

Area* Area::New() const {
  return new Area;
}

void Area::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (northeast_ != NULL) northeast_->::ProtocolBuffer::Location::Clear();
    }
    if (_has_bit(1)) {
      if (southwest_ != NULL) southwest_->::ProtocolBuffer::Location::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Area::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtocolBuffer.Location northeast = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_northeast()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_southwest;
        break;
      }
      
      // required .ProtocolBuffer.Location southwest = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_southwest:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_southwest()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Area::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ProtocolBuffer.Location northeast = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->northeast(), output);
  }
  
  // required .ProtocolBuffer.Location southwest = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->southwest(), output);
  }
  
}

int Area::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtocolBuffer.Location northeast = 1;
    if (has_northeast()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->northeast());
    }
    
    // required .ProtocolBuffer.Location southwest = 2;
    if (has_southwest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->southwest());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Area::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Area*>(&from));
}

void Area::MergeFrom(const Area& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_northeast()->::ProtocolBuffer::Location::MergeFrom(from.northeast());
    }
    if (from._has_bit(1)) {
      mutable_southwest()->::ProtocolBuffer::Location::MergeFrom(from.southwest());
    }
  }
}

void Area::CopyFrom(const Area& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Area::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_northeast()) {
    if (!this->northeast().IsInitialized()) return false;
  }
  if (has_southwest()) {
    if (!this->southwest().IsInitialized()) return false;
  }
  return true;
}

void Area::Swap(Area* other) {
  if (other != this) {
    std::swap(northeast_, other->northeast_);
    std::swap(southwest_, other->southwest_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Area::GetTypeName() const {
  return "ProtocolBuffer.Area";
}


// ===================================================================

const ::std::string Time::_default_timestamp_;
#ifndef _MSC_VER
const int Time::kTimeStampFieldNumber;
#endif  // !_MSC_VER

Time::Time()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Time::InitAsDefaultInstance() {
}

Time::Time(const Time& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Time::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = const_cast< ::std::string*>(&_default_timestamp_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Time::~Time() {
  SharedDtor();
}

void Time::SharedDtor() {
  if (timestamp_ != &_default_timestamp_) {
    delete timestamp_;
  }
  if (this != default_instance_) {
  }
}

void Time::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Time& Time::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Time* Time::default_instance_ = NULL;

Time* Time::New() const {
  return new Time;
}

void Time::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (timestamp_ != &_default_timestamp_) {
        timestamp_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Time::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string timeStamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_timestamp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Time::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string timeStamp = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->timestamp(), output);
  }
  
}

int Time::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string timeStamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->timestamp());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Time::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Time*>(&from));
}

void Time::MergeFrom(const Time& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_timestamp(from.timestamp());
    }
  }
}

void Time::CopyFrom(const Time& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Time::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Time::Swap(Time* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Time::GetTypeName() const {
  return "ProtocolBuffer.Time";
}


// ===================================================================

const ::std::string Comment::_default_content_;
#ifndef _MSC_VER
const int Comment::kContentFieldNumber;
const int Comment::kTimeStampFieldNumber;
const int Comment::kUIDFieldNumber;
const int Comment::kRIDFieldNumber;
const int Comment::kDIDFieldNumber;
#endif  // !_MSC_VER

Comment::Comment()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Comment::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::ProtocolBuffer::Time*>(&::ProtocolBuffer::Time::default_instance());
}

Comment::Comment(const Comment& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Comment::SharedCtor() {
  _cached_size_ = 0;
  content_ = const_cast< ::std::string*>(&_default_content_);
  timestamp_ = NULL;
  uid_ = 0u;
  rid_ = 0u;
  did_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Comment::~Comment() {
  SharedDtor();
}

void Comment::SharedDtor() {
  if (content_ != &_default_content_) {
    delete content_;
  }
  if (this != default_instance_) {
    delete timestamp_;
  }
}

void Comment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Comment& Comment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Comment* Comment::default_instance_ = NULL;

Comment* Comment::New() const {
  return new Comment;
}

void Comment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (content_ != &_default_content_) {
        content_->clear();
      }
    }
    if (_has_bit(1)) {
      if (timestamp_ != NULL) timestamp_->::ProtocolBuffer::Time::Clear();
    }
    uid_ = 0u;
    rid_ = 0u;
    did_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Comment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string content = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_timeStamp;
        break;
      }
      
      // required .ProtocolBuffer.Time timeStamp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_timeStamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_UID;
        break;
      }
      
      // required uint32 UID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_UID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_RID;
        break;
      }
      
      // required uint32 RID = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rid_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_DID;
        break;
      }
      
      // optional uint32 DID = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &did_)));
          _set_bit(4);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Comment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string content = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->content(), output);
  }
  
  // required .ProtocolBuffer.Time timeStamp = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->timestamp(), output);
  }
  
  // required uint32 UID = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->uid(), output);
  }
  
  // required uint32 RID = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->rid(), output);
  }
  
  // optional uint32 DID = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->did(), output);
  }
  
}

int Comment::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string content = 1;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }
    
    // required .ProtocolBuffer.Time timeStamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->timestamp());
    }
    
    // required uint32 UID = 3;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }
    
    // required uint32 RID = 4;
    if (has_rid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rid());
    }
    
    // optional uint32 DID = 5;
    if (has_did()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->did());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Comment::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Comment*>(&from));
}

void Comment::MergeFrom(const Comment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_content(from.content());
    }
    if (from._has_bit(1)) {
      mutable_timestamp()->::ProtocolBuffer::Time::MergeFrom(from.timestamp());
    }
    if (from._has_bit(2)) {
      set_uid(from.uid());
    }
    if (from._has_bit(3)) {
      set_rid(from.rid());
    }
    if (from._has_bit(4)) {
      set_did(from.did());
    }
  }
}

void Comment::CopyFrom(const Comment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Comment::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_timestamp()) {
    if (!this->timestamp().IsInitialized()) return false;
  }
  return true;
}

void Comment::Swap(Comment* other) {
  if (other != this) {
    std::swap(content_, other->content_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(uid_, other->uid_);
    std::swap(rid_, other->rid_);
    std::swap(did_, other->did_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Comment::GetTypeName() const {
  return "ProtocolBuffer.Comment";
}


// ===================================================================

#ifndef _MSC_VER
const int Currency::kAmountFieldNumber;
#endif  // !_MSC_VER

Currency::Currency()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Currency::InitAsDefaultInstance() {
}

Currency::Currency(const Currency& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Currency::SharedCtor() {
  _cached_size_ = 0;
  amount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Currency::~Currency() {
  SharedDtor();
}

void Currency::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Currency::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Currency& Currency::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Currency* Currency::default_instance_ = NULL;

Currency* Currency::New() const {
  return new Currency;
}

void Currency::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    amount_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Currency::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float amount = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &amount_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Currency::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float amount = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->amount(), output);
  }
  
}

int Currency::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float amount = 1;
    if (has_amount()) {
      total_size += 1 + 4;
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Currency::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Currency*>(&from));
}

void Currency::MergeFrom(const Currency& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_amount(from.amount());
    }
  }
}

void Currency::CopyFrom(const Currency& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Currency::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Currency::Swap(Currency* other) {
  if (other != this) {
    std::swap(amount_, other->amount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Currency::GetTypeName() const {
  return "ProtocolBuffer.Currency";
}


// ===================================================================

const ::std::string Error::_default_message_;
#ifndef _MSC_VER
const int Error::kMessageFieldNumber;
#endif  // !_MSC_VER

Error::Error()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Error::InitAsDefaultInstance() {
}

Error::Error(const Error& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Error::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&_default_message_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Error::~Error() {
  SharedDtor();
}

void Error::SharedDtor() {
  if (message_ != &_default_message_) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void Error::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Error& Error::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Error* Error::default_instance_ = NULL;

Error* Error::New() const {
  return new Error;
}

void Error::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (message_ != &_default_message_) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string message = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string message = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->message(), output);
  }
  
}

int Error::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Error::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Error*>(&from));
}

void Error::MergeFrom(const Error& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_message(from.message());
    }
  }
}

void Error::CopyFrom(const Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Error::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Error::Swap(Error* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Error::GetTypeName() const {
  return "ProtocolBuffer.Error";
}


// ===================================================================

const ::std::string User::_default_emailaddress_;
const ::std::string User::_default_nickname_;
const ::std::string User::_default_password_;
#ifndef _MSC_VER
const int User::kUIDFieldNumber;
const int User::kEmailAddressFieldNumber;
const int User::kNickNameFieldNumber;
const int User::kPasswordFieldNumber;
const int User::kJoinTimeFieldNumber;
const int User::kLastLocationFieldNumber;
const int User::kPreferTypesFieldNumber;
const int User::kFriendsFieldNumber;
#endif  // !_MSC_VER

User::User()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void User::InitAsDefaultInstance() {
  jointime_ = const_cast< ::ProtocolBuffer::Time*>(&::ProtocolBuffer::Time::default_instance());
  lastlocation_ = const_cast< ::ProtocolBuffer::Location*>(&::ProtocolBuffer::Location::default_instance());
}

User::User(const User& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void User::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0u;
  emailaddress_ = const_cast< ::std::string*>(&_default_emailaddress_);
  nickname_ = const_cast< ::std::string*>(&_default_nickname_);
  password_ = const_cast< ::std::string*>(&_default_password_);
  jointime_ = NULL;
  lastlocation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

User::~User() {
  SharedDtor();
}

void User::SharedDtor() {
  if (emailaddress_ != &_default_emailaddress_) {
    delete emailaddress_;
  }
  if (nickname_ != &_default_nickname_) {
    delete nickname_;
  }
  if (password_ != &_default_password_) {
    delete password_;
  }
  if (this != default_instance_) {
    delete jointime_;
    delete lastlocation_;
  }
}

void User::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const User& User::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

User* User::default_instance_ = NULL;

User* User::New() const {
  return new User;
}

void User::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0u;
    if (_has_bit(1)) {
      if (emailaddress_ != &_default_emailaddress_) {
        emailaddress_->clear();
      }
    }
    if (_has_bit(2)) {
      if (nickname_ != &_default_nickname_) {
        nickname_->clear();
      }
    }
    if (_has_bit(3)) {
      if (password_ != &_default_password_) {
        password_->clear();
      }
    }
    if (_has_bit(4)) {
      if (jointime_ != NULL) jointime_->::ProtocolBuffer::Time::Clear();
    }
    if (_has_bit(5)) {
      if (lastlocation_ != NULL) lastlocation_->::ProtocolBuffer::Location::Clear();
    }
  }
  prefertypes_.Clear();
  friends_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool User::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 UID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_emailAddress;
        break;
      }
      
      // required string emailAddress = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_emailAddress:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_emailaddress()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_nickName;
        break;
      }
      
      // required string nickName = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nickName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nickname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_password;
        break;
      }
      
      // required string password = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_joinTime;
        break;
      }
      
      // required .ProtocolBuffer.Time joinTime = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_joinTime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_jointime()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_lastLocation;
        break;
      }
      
      // optional .ProtocolBuffer.Location lastLocation = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lastLocation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lastlocation()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_preferTypes;
        break;
      }
      
      // repeated .ProtocolBuffer.RestaurantType preferTypes = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_preferTypes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_prefertypes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_preferTypes;
        if (input->ExpectTag(64)) goto parse_friends;
        break;
      }
      
      // repeated uint32 friends = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_friends:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 64, input, this->mutable_friends())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_friends())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_friends;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void User::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 UID = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uid(), output);
  }
  
  // required string emailAddress = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->emailaddress(), output);
  }
  
  // required string nickName = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->nickname(), output);
  }
  
  // required string password = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->password(), output);
  }
  
  // required .ProtocolBuffer.Time joinTime = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->jointime(), output);
  }
  
  // optional .ProtocolBuffer.Location lastLocation = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->lastlocation(), output);
  }
  
  // repeated .ProtocolBuffer.RestaurantType preferTypes = 7;
  for (int i = 0; i < this->prefertypes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->prefertypes(i), output);
  }
  
  // repeated uint32 friends = 8;
  for (int i = 0; i < this->friends_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      8, this->friends(i), output);
  }
  
}

int User::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 UID = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }
    
    // required string emailAddress = 2;
    if (has_emailaddress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->emailaddress());
    }
    
    // required string nickName = 3;
    if (has_nickname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->nickname());
    }
    
    // required string password = 4;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }
    
    // required .ProtocolBuffer.Time joinTime = 5;
    if (has_jointime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->jointime());
    }
    
    // optional .ProtocolBuffer.Location lastLocation = 6;
    if (has_lastlocation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lastlocation());
    }
    
  }
  // repeated .ProtocolBuffer.RestaurantType preferTypes = 7;
  total_size += 1 * this->prefertypes_size();
  for (int i = 0; i < this->prefertypes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->prefertypes(i));
  }
  
  // repeated uint32 friends = 8;
  {
    int data_size = 0;
    for (int i = 0; i < this->friends_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->friends(i));
    }
    total_size += 1 * this->friends_size() + data_size;
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void User::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const User*>(&from));
}

void User::MergeFrom(const User& from) {
  GOOGLE_CHECK_NE(&from, this);
  prefertypes_.MergeFrom(from.prefertypes_);
  friends_.MergeFrom(from.friends_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_uid(from.uid());
    }
    if (from._has_bit(1)) {
      set_emailaddress(from.emailaddress());
    }
    if (from._has_bit(2)) {
      set_nickname(from.nickname());
    }
    if (from._has_bit(3)) {
      set_password(from.password());
    }
    if (from._has_bit(4)) {
      mutable_jointime()->::ProtocolBuffer::Time::MergeFrom(from.jointime());
    }
    if (from._has_bit(5)) {
      mutable_lastlocation()->::ProtocolBuffer::Location::MergeFrom(from.lastlocation());
    }
  }
}

void User::CopyFrom(const User& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool User::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  if (has_jointime()) {
    if (!this->jointime().IsInitialized()) return false;
  }
  if (has_lastlocation()) {
    if (!this->lastlocation().IsInitialized()) return false;
  }
  for (int i = 0; i < prefertypes_size(); i++) {
    if (!this->prefertypes(i).IsInitialized()) return false;
  }
  return true;
}

void User::Swap(User* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(emailaddress_, other->emailaddress_);
    std::swap(nickname_, other->nickname_);
    std::swap(password_, other->password_);
    std::swap(jointime_, other->jointime_);
    std::swap(lastlocation_, other->lastlocation_);
    prefertypes_.Swap(&other->prefertypes_);
    friends_.Swap(&other->friends_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string User::GetTypeName() const {
  return "ProtocolBuffer.User";
}


// ===================================================================

const ::std::string Restaurant::_default_name_;
#ifndef _MSC_VER
const int Restaurant::kLocationFieldNumber;
const int Restaurant::kNameFieldNumber;
const int Restaurant::kRIDFieldNumber;
const int Restaurant::kTypeFieldNumber;
const int Restaurant::kRatingFieldNumber;
const int Restaurant::kCommentCountFieldNumber;
const int Restaurant::kAverageExpenseFieldNumber;
#endif  // !_MSC_VER

Restaurant::Restaurant()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Restaurant::InitAsDefaultInstance() {
  location_ = const_cast< ::ProtocolBuffer::Location*>(&::ProtocolBuffer::Location::default_instance());
  type_ = const_cast< ::ProtocolBuffer::RestaurantType*>(&::ProtocolBuffer::RestaurantType::default_instance());
  averageexpense_ = const_cast< ::ProtocolBuffer::Currency*>(&::ProtocolBuffer::Currency::default_instance());
}

Restaurant::Restaurant(const Restaurant& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Restaurant::SharedCtor() {
  _cached_size_ = 0;
  location_ = NULL;
  name_ = const_cast< ::std::string*>(&_default_name_);
  rid_ = 0u;
  type_ = NULL;
  rating_ = 0u;
  commentcount_ = 0u;
  averageexpense_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Restaurant::~Restaurant() {
  SharedDtor();
}

void Restaurant::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (this != default_instance_) {
    delete location_;
    delete type_;
    delete averageexpense_;
  }
}

void Restaurant::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Restaurant& Restaurant::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Restaurant* Restaurant::default_instance_ = NULL;

Restaurant* Restaurant::New() const {
  return new Restaurant;
}

void Restaurant::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (location_ != NULL) location_->::ProtocolBuffer::Location::Clear();
    }
    if (_has_bit(1)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    rid_ = 0u;
    if (_has_bit(3)) {
      if (type_ != NULL) type_->::ProtocolBuffer::RestaurantType::Clear();
    }
    rating_ = 0u;
    commentcount_ = 0u;
    if (_has_bit(6)) {
      if (averageexpense_ != NULL) averageexpense_->::ProtocolBuffer::Currency::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Restaurant::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtocolBuffer.Location location = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_RID;
        break;
      }
      
      // required uint32 RID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rid_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_type;
        break;
      }
      
      // required .ProtocolBuffer.RestaurantType type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Rating;
        break;
      }
      
      // required uint32 Rating = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Rating:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rating_)));
          _set_bit(4);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_CommentCount;
        break;
      }
      
      // required uint32 CommentCount = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CommentCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &commentcount_)));
          _set_bit(5);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_averageExpense;
        break;
      }
      
      // required .ProtocolBuffer.Currency averageExpense = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_averageExpense:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_averageexpense()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Restaurant::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ProtocolBuffer.Location location = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->location(), output);
  }
  
  // required string name = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  // required uint32 RID = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->rid(), output);
  }
  
  // required .ProtocolBuffer.RestaurantType type = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->type(), output);
  }
  
  // required uint32 Rating = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->rating(), output);
  }
  
  // required uint32 CommentCount = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->commentcount(), output);
  }
  
  // required .ProtocolBuffer.Currency averageExpense = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->averageexpense(), output);
  }
  
}

int Restaurant::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtocolBuffer.Location location = 1;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }
    
    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required uint32 RID = 3;
    if (has_rid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rid());
    }
    
    // required .ProtocolBuffer.RestaurantType type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->type());
    }
    
    // required uint32 Rating = 5;
    if (has_rating()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rating());
    }
    
    // required uint32 CommentCount = 6;
    if (has_commentcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->commentcount());
    }
    
    // required .ProtocolBuffer.Currency averageExpense = 7;
    if (has_averageexpense()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->averageexpense());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Restaurant::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Restaurant*>(&from));
}

void Restaurant::MergeFrom(const Restaurant& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_location()->::ProtocolBuffer::Location::MergeFrom(from.location());
    }
    if (from._has_bit(1)) {
      set_name(from.name());
    }
    if (from._has_bit(2)) {
      set_rid(from.rid());
    }
    if (from._has_bit(3)) {
      mutable_type()->::ProtocolBuffer::RestaurantType::MergeFrom(from.type());
    }
    if (from._has_bit(4)) {
      set_rating(from.rating());
    }
    if (from._has_bit(5)) {
      set_commentcount(from.commentcount());
    }
    if (from._has_bit(6)) {
      mutable_averageexpense()->::ProtocolBuffer::Currency::MergeFrom(from.averageexpense());
    }
  }
}

void Restaurant::CopyFrom(const Restaurant& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Restaurant::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;
  
  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  if (has_type()) {
    if (!this->type().IsInitialized()) return false;
  }
  if (has_averageexpense()) {
    if (!this->averageexpense().IsInitialized()) return false;
  }
  return true;
}

void Restaurant::Swap(Restaurant* other) {
  if (other != this) {
    std::swap(location_, other->location_);
    std::swap(name_, other->name_);
    std::swap(rid_, other->rid_);
    std::swap(type_, other->type_);
    std::swap(rating_, other->rating_);
    std::swap(commentcount_, other->commentcount_);
    std::swap(averageexpense_, other->averageexpense_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Restaurant::GetTypeName() const {
  return "ProtocolBuffer.Restaurant";
}


// ===================================================================

#ifndef _MSC_VER
const int RestaurantList::kRestaurantsFieldNumber;
#endif  // !_MSC_VER

RestaurantList::RestaurantList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RestaurantList::InitAsDefaultInstance() {
}

RestaurantList::RestaurantList(const RestaurantList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RestaurantList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RestaurantList::~RestaurantList() {
  SharedDtor();
}

void RestaurantList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RestaurantList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RestaurantList& RestaurantList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

RestaurantList* RestaurantList::default_instance_ = NULL;

RestaurantList* RestaurantList::New() const {
  return new RestaurantList;
}

void RestaurantList::Clear() {
  restaurants_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RestaurantList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ProtocolBuffer.Restaurant restaurants = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_restaurants:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_restaurants()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_restaurants;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RestaurantList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ProtocolBuffer.Restaurant restaurants = 1;
  for (int i = 0; i < this->restaurants_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->restaurants(i), output);
  }
  
}

int RestaurantList::ByteSize() const {
  int total_size = 0;
  
  // repeated .ProtocolBuffer.Restaurant restaurants = 1;
  total_size += 1 * this->restaurants_size();
  for (int i = 0; i < this->restaurants_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->restaurants(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RestaurantList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RestaurantList*>(&from));
}

void RestaurantList::MergeFrom(const RestaurantList& from) {
  GOOGLE_CHECK_NE(&from, this);
  restaurants_.MergeFrom(from.restaurants_);
}

void RestaurantList::CopyFrom(const RestaurantList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RestaurantList::IsInitialized() const {
  
  for (int i = 0; i < restaurants_size(); i++) {
    if (!this->restaurants(i).IsInitialized()) return false;
  }
  return true;
}

void RestaurantList::Swap(RestaurantList* other) {
  if (other != this) {
    restaurants_.Swap(&other->restaurants_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RestaurantList::GetTypeName() const {
  return "ProtocolBuffer.RestaurantList";
}


// ===================================================================

#ifndef _MSC_VER
const int CommentList::kCommentsFieldNumber;
#endif  // !_MSC_VER

CommentList::CommentList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CommentList::InitAsDefaultInstance() {
}

CommentList::CommentList(const CommentList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CommentList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommentList::~CommentList() {
  SharedDtor();
}

void CommentList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CommentList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CommentList& CommentList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

CommentList* CommentList::default_instance_ = NULL;

CommentList* CommentList::New() const {
  return new CommentList;
}

void CommentList::Clear() {
  comments_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CommentList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ProtocolBuffer.Comment comments = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_comments:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_comments()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_comments;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CommentList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ProtocolBuffer.Comment comments = 1;
  for (int i = 0; i < this->comments_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->comments(i), output);
  }
  
}

int CommentList::ByteSize() const {
  int total_size = 0;
  
  // repeated .ProtocolBuffer.Comment comments = 1;
  total_size += 1 * this->comments_size();
  for (int i = 0; i < this->comments_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->comments(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommentList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CommentList*>(&from));
}

void CommentList::MergeFrom(const CommentList& from) {
  GOOGLE_CHECK_NE(&from, this);
  comments_.MergeFrom(from.comments_);
}

void CommentList::CopyFrom(const CommentList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommentList::IsInitialized() const {
  
  for (int i = 0; i < comments_size(); i++) {
    if (!this->comments(i).IsInitialized()) return false;
  }
  return true;
}

void CommentList::Swap(CommentList* other) {
  if (other != this) {
    comments_.Swap(&other->comments_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CommentList::GetTypeName() const {
  return "ProtocolBuffer.CommentList";
}


// ===================================================================

#ifndef _MSC_VER
const int UserList::kUsersFieldNumber;
#endif  // !_MSC_VER

UserList::UserList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UserList::InitAsDefaultInstance() {
}

UserList::UserList(const UserList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UserList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserList::~UserList() {
  SharedDtor();
}

void UserList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UserList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserList& UserList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

UserList* UserList::default_instance_ = NULL;

UserList* UserList::New() const {
  return new UserList;
}

void UserList::Clear() {
  users_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UserList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ProtocolBuffer.User users = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_users:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_users()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_users;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ProtocolBuffer.User users = 1;
  for (int i = 0; i < this->users_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->users(i), output);
  }
  
}

int UserList::ByteSize() const {
  int total_size = 0;
  
  // repeated .ProtocolBuffer.User users = 1;
  total_size += 1 * this->users_size();
  for (int i = 0; i < this->users_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->users(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserList*>(&from));
}

void UserList::MergeFrom(const UserList& from) {
  GOOGLE_CHECK_NE(&from, this);
  users_.MergeFrom(from.users_);
}

void UserList::CopyFrom(const UserList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserList::IsInitialized() const {
  
  for (int i = 0; i < users_size(); i++) {
    if (!this->users(i).IsInitialized()) return false;
  }
  return true;
}

void UserList::Swap(UserList* other) {
  if (other != this) {
    users_.Swap(&other->users_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserList::GetTypeName() const {
  return "ProtocolBuffer.UserList";
}


// ===================================================================

const ::std::string RestaurantType::_default_name_;
#ifndef _MSC_VER
const int RestaurantType::kTIDFieldNumber;
const int RestaurantType::kNameFieldNumber;
#endif  // !_MSC_VER

RestaurantType::RestaurantType()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RestaurantType::InitAsDefaultInstance() {
}

RestaurantType::RestaurantType(const RestaurantType& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RestaurantType::SharedCtor() {
  _cached_size_ = 0;
  tid_ = 0u;
  name_ = const_cast< ::std::string*>(&_default_name_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RestaurantType::~RestaurantType() {
  SharedDtor();
}

void RestaurantType::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void RestaurantType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RestaurantType& RestaurantType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

RestaurantType* RestaurantType::default_instance_ = NULL;

RestaurantType* RestaurantType::New() const {
  return new RestaurantType;
}

void RestaurantType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tid_ = 0u;
    if (_has_bit(1)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RestaurantType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 TID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tid_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RestaurantType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 TID = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->tid(), output);
  }
  
  // required string name = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
}

int RestaurantType::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 TID = 1;
    if (has_tid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tid());
    }
    
    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RestaurantType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RestaurantType*>(&from));
}

void RestaurantType::MergeFrom(const RestaurantType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_tid(from.tid());
    }
    if (from._has_bit(1)) {
      set_name(from.name());
    }
  }
}

void RestaurantType::CopyFrom(const RestaurantType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RestaurantType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void RestaurantType::Swap(RestaurantType* other) {
  if (other != this) {
    std::swap(tid_, other->tid_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RestaurantType::GetTypeName() const {
  return "ProtocolBuffer.RestaurantType";
}


// ===================================================================

const ::std::string Query::_default_msg_;
const ::std::string Query::_default_image_;
const ::std::string Query::_default_emailaddress_;
const ::std::string Query::_default_password_;
#ifndef _MSC_VER
const int Query::kAreaFieldNumber;
const int Query::kLevelFieldNumber;
const int Query::kTimeFieldNumber;
const int Query::kRIDFieldNumber;
const int Query::kUIDFieldNumber;
const int Query::kNFieldNumber;
const int Query::kRelationFieldNumber;
const int Query::kMsgFieldNumber;
const int Query::kImageFieldNumber;
const int Query::kEmailAddressFieldNumber;
const int Query::kPasswordFieldNumber;
const int Query::kUserinfoFieldNumber;
#endif  // !_MSC_VER

Query::Query()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Query::InitAsDefaultInstance() {
  area_ = const_cast< ::ProtocolBuffer::Area*>(&::ProtocolBuffer::Area::default_instance());
  time_ = const_cast< ::ProtocolBuffer::Time*>(&::ProtocolBuffer::Time::default_instance());
  userinfo_ = const_cast< ::ProtocolBuffer::User*>(&::ProtocolBuffer::User::default_instance());
}

Query::Query(const Query& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Query::SharedCtor() {
  _cached_size_ = 0;
  area_ = NULL;
  level_ = 0u;
  time_ = NULL;
  rid_ = 0u;
  uid_ = 0u;
  n_ = 0u;
  relation_ = 0u;
  msg_ = const_cast< ::std::string*>(&_default_msg_);
  image_ = const_cast< ::std::string*>(&_default_image_);
  emailaddress_ = const_cast< ::std::string*>(&_default_emailaddress_);
  password_ = const_cast< ::std::string*>(&_default_password_);
  userinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Query::~Query() {
  SharedDtor();
}

void Query::SharedDtor() {
  if (msg_ != &_default_msg_) {
    delete msg_;
  }
  if (image_ != &_default_image_) {
    delete image_;
  }
  if (emailaddress_ != &_default_emailaddress_) {
    delete emailaddress_;
  }
  if (password_ != &_default_password_) {
    delete password_;
  }
  if (this != default_instance_) {
    delete area_;
    delete time_;
    delete userinfo_;
  }
}

void Query::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Query& Query::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Query* Query::default_instance_ = NULL;

Query* Query::New() const {
  return new Query;
}

void Query::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (area_ != NULL) area_->::ProtocolBuffer::Area::Clear();
    }
    level_ = 0u;
    if (_has_bit(2)) {
      if (time_ != NULL) time_->::ProtocolBuffer::Time::Clear();
    }
    rid_ = 0u;
    uid_ = 0u;
    n_ = 0u;
    relation_ = 0u;
    if (_has_bit(7)) {
      if (msg_ != &_default_msg_) {
        msg_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (_has_bit(8)) {
      if (image_ != &_default_image_) {
        image_->clear();
      }
    }
    if (_has_bit(9)) {
      if (emailaddress_ != &_default_emailaddress_) {
        emailaddress_->clear();
      }
    }
    if (_has_bit(10)) {
      if (password_ != &_default_password_) {
        password_->clear();
      }
    }
    if (_has_bit(11)) {
      if (userinfo_ != NULL) userinfo_->::ProtocolBuffer::User::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Query::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ProtocolBuffer.Area area = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_area()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_level;
        break;
      }
      
      // optional uint32 level = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_time;
        break;
      }
      
      // optional .ProtocolBuffer.Time time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_RID;
        break;
      }
      
      // optional uint32 RID = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rid_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_UID;
        break;
      }
      
      // optional uint32 UID = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_UID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          _set_bit(4);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_n;
        break;
      }
      
      // optional uint32 n = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &n_)));
          _set_bit(5);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_msg;
        break;
      }
      
      // optional string msg = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_image;
        break;
      }
      
      // optional bytes image = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_image()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_emailAddress;
        break;
      }
      
      // optional string emailAddress = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_emailAddress:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_emailaddress()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_password;
        break;
      }
      
      // optional string password = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_userinfo;
        break;
      }
      
      // optional .ProtocolBuffer.User userinfo = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_userinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_userinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_relation;
        break;
      }
      
      // optional uint32 relation = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_relation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &relation_)));
          _set_bit(6);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Query::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ProtocolBuffer.Area area = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->area(), output);
  }
  
  // optional uint32 level = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->level(), output);
  }
  
  // optional .ProtocolBuffer.Time time = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->time(), output);
  }
  
  // optional uint32 RID = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->rid(), output);
  }
  
  // optional uint32 UID = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->uid(), output);
  }
  
  // optional uint32 n = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->n(), output);
  }
  
  // optional string msg = 7;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->msg(), output);
  }
  
  // optional bytes image = 8;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->image(), output);
  }
  
  // optional string emailAddress = 9;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->emailaddress(), output);
  }
  
  // optional string password = 10;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->password(), output);
  }
  
  // optional .ProtocolBuffer.User userinfo = 11;
  if (_has_bit(11)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->userinfo(), output);
  }
  
  // optional uint32 relation = 12;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->relation(), output);
  }
  
}

int Query::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ProtocolBuffer.Area area = 1;
    if (has_area()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->area());
    }
    
    // optional uint32 level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }
    
    // optional .ProtocolBuffer.Time time = 3;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->time());
    }
    
    // optional uint32 RID = 4;
    if (has_rid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rid());
    }
    
    // optional uint32 UID = 5;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }
    
    // optional uint32 n = 6;
    if (has_n()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->n());
    }
    
    // optional uint32 relation = 12;
    if (has_relation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->relation());
    }
    
    // optional string msg = 7;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes image = 8;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->image());
    }
    
    // optional string emailAddress = 9;
    if (has_emailaddress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->emailaddress());
    }
    
    // optional string password = 10;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }
    
    // optional .ProtocolBuffer.User userinfo = 11;
    if (has_userinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->userinfo());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Query::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Query*>(&from));
}

void Query::MergeFrom(const Query& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_area()->::ProtocolBuffer::Area::MergeFrom(from.area());
    }
    if (from._has_bit(1)) {
      set_level(from.level());
    }
    if (from._has_bit(2)) {
      mutable_time()->::ProtocolBuffer::Time::MergeFrom(from.time());
    }
    if (from._has_bit(3)) {
      set_rid(from.rid());
    }
    if (from._has_bit(4)) {
      set_uid(from.uid());
    }
    if (from._has_bit(5)) {
      set_n(from.n());
    }
    if (from._has_bit(6)) {
      set_relation(from.relation());
    }
    if (from._has_bit(7)) {
      set_msg(from.msg());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      set_image(from.image());
    }
    if (from._has_bit(9)) {
      set_emailaddress(from.emailaddress());
    }
    if (from._has_bit(10)) {
      set_password(from.password());
    }
    if (from._has_bit(11)) {
      mutable_userinfo()->::ProtocolBuffer::User::MergeFrom(from.userinfo());
    }
  }
}

void Query::CopyFrom(const Query& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Query::IsInitialized() const {
  
  if (has_area()) {
    if (!this->area().IsInitialized()) return false;
  }
  if (has_time()) {
    if (!this->time().IsInitialized()) return false;
  }
  if (has_userinfo()) {
    if (!this->userinfo().IsInitialized()) return false;
  }
  return true;
}

void Query::Swap(Query* other) {
  if (other != this) {
    std::swap(area_, other->area_);
    std::swap(level_, other->level_);
    std::swap(time_, other->time_);
    std::swap(rid_, other->rid_);
    std::swap(uid_, other->uid_);
    std::swap(n_, other->n_);
    std::swap(relation_, other->relation_);
    std::swap(msg_, other->msg_);
    std::swap(image_, other->image_);
    std::swap(emailaddress_, other->emailaddress_);
    std::swap(password_, other->password_);
    std::swap(userinfo_, other->userinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Query::GetTypeName() const {
  return "ProtocolBuffer.Query";
}


// ===================================================================

const ::std::string DMessage::_default_text_;
const ::std::string DMessage::_default_buffer_;
#ifndef _MSC_VER
const int DMessage::kFromUserFieldNumber;
const int DMessage::kToUserFieldNumber;
const int DMessage::kMsgIDFieldNumber;
const int DMessage::kIsSystemMessageFieldNumber;
const int DMessage::kTextFieldNumber;
const int DMessage::kSystemMessageTypeFieldNumber;
const int DMessage::kBufferFieldNumber;
#endif  // !_MSC_VER

DMessage::DMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DMessage::InitAsDefaultInstance() {
}

DMessage::DMessage(const DMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DMessage::SharedCtor() {
  _cached_size_ = 0;
  fromuser_ = 0u;
  touser_ = 0u;
  msgid_ = 0u;
  issystemmessage_ = false;
  text_ = const_cast< ::std::string*>(&_default_text_);
  systemmessagetype_ = 1;
  buffer_ = const_cast< ::std::string*>(&_default_buffer_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DMessage::~DMessage() {
  SharedDtor();
}

void DMessage::SharedDtor() {
  if (text_ != &_default_text_) {
    delete text_;
  }
  if (buffer_ != &_default_buffer_) {
    delete buffer_;
  }
  if (this != default_instance_) {
  }
}

void DMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DMessage& DMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

DMessage* DMessage::default_instance_ = NULL;

DMessage* DMessage::New() const {
  return new DMessage;
}

void DMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    fromuser_ = 0u;
    touser_ = 0u;
    msgid_ = 0u;
    issystemmessage_ = false;
    if (_has_bit(4)) {
      if (text_ != &_default_text_) {
        text_->clear();
      }
    }
    systemmessagetype_ = 1;
    if (_has_bit(6)) {
      if (buffer_ != &_default_buffer_) {
        buffer_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 fromUser = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fromuser_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_toUser;
        break;
      }
      
      // required uint32 toUser = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_toUser:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &touser_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_text;
        break;
      }
      
      // optional string text = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_systemMessageType;
        break;
      }
      
      // optional .ProtocolBuffer.SystemMessageType systemMessageType = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_systemMessageType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (ProtocolBuffer::SystemMessageType_IsValid(value)) {
            set_systemmessagetype(static_cast< ProtocolBuffer::SystemMessageType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_buffer;
        break;
      }
      
      // optional string buffer = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_buffer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buffer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_msgID;
        break;
      }
      
      // required uint32 msgID = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_msgID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msgid_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_isSystemMessage;
        break;
      }
      
      // required bool isSystemMessage = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isSystemMessage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &issystemmessage_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 fromUser = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->fromuser(), output);
  }
  
  // required uint32 toUser = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->touser(), output);
  }
  
  // optional string text = 3;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->text(), output);
  }
  
  // optional .ProtocolBuffer.SystemMessageType systemMessageType = 4;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->systemmessagetype(), output);
  }
  
  // optional string buffer = 5;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->buffer(), output);
  }
  
  // required uint32 msgID = 6;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->msgid(), output);
  }
  
  // required bool isSystemMessage = 7;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->issystemmessage(), output);
  }
  
}

int DMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 fromUser = 1;
    if (has_fromuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fromuser());
    }
    
    // required uint32 toUser = 2;
    if (has_touser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->touser());
    }
    
    // required uint32 msgID = 6;
    if (has_msgid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msgid());
    }
    
    // required bool isSystemMessage = 7;
    if (has_issystemmessage()) {
      total_size += 1 + 1;
    }
    
    // optional string text = 3;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }
    
    // optional .ProtocolBuffer.SystemMessageType systemMessageType = 4;
    if (has_systemmessagetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->systemmessagetype());
    }
    
    // optional string buffer = 5;
    if (has_buffer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buffer());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DMessage*>(&from));
}

void DMessage::MergeFrom(const DMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_fromuser(from.fromuser());
    }
    if (from._has_bit(1)) {
      set_touser(from.touser());
    }
    if (from._has_bit(2)) {
      set_msgid(from.msgid());
    }
    if (from._has_bit(3)) {
      set_issystemmessage(from.issystemmessage());
    }
    if (from._has_bit(4)) {
      set_text(from.text());
    }
    if (from._has_bit(5)) {
      set_systemmessagetype(from.systemmessagetype());
    }
    if (from._has_bit(6)) {
      set_buffer(from.buffer());
    }
  }
}

void DMessage::CopyFrom(const DMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void DMessage::Swap(DMessage* other) {
  if (other != this) {
    std::swap(fromuser_, other->fromuser_);
    std::swap(touser_, other->touser_);
    std::swap(msgid_, other->msgid_);
    std::swap(issystemmessage_, other->issystemmessage_);
    std::swap(text_, other->text_);
    std::swap(systemmessagetype_, other->systemmessagetype_);
    std::swap(buffer_, other->buffer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DMessage::GetTypeName() const {
  return "ProtocolBuffer.DMessage";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtocolBuffer

// @@protoc_insertion_point(global_scope)
