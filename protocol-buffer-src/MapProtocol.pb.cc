// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "MapProtocol.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>

namespace ProtocolBuffer {

namespace {

const ::google::protobuf::Descriptor* Location_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Location_reflection_ = NULL;
const ::google::protobuf::Descriptor* Area_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Area_reflection_ = NULL;
const ::google::protobuf::Descriptor* Time_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Time_reflection_ = NULL;
const ::google::protobuf::Descriptor* Comment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Comment_reflection_ = NULL;
const ::google::protobuf::Descriptor* Currency_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Currency_reflection_ = NULL;
const ::google::protobuf::Descriptor* Error_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Error_reflection_ = NULL;
const ::google::protobuf::Descriptor* User_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  User_reflection_ = NULL;
const ::google::protobuf::Descriptor* Restaurant_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Restaurant_reflection_ = NULL;
const ::google::protobuf::Descriptor* RestaurantList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RestaurantList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CommentList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CommentList_reflection_ = NULL;
const ::google::protobuf::Descriptor* RestaurantType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RestaurantType_reflection_ = NULL;
const ::google::protobuf::Descriptor* Query_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Query_reflection_ = NULL;
const ::google::protobuf::ServiceDescriptor* DMService_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_MapProtocol_2eproto() {
  protobuf_AddDesc_MapProtocol_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "MapProtocol.proto");
  GOOGLE_CHECK(file != NULL);
  Location_descriptor_ = file->message_type(0);
  static const int Location_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, latitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, longitude_),
  };
  Location_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Location_descriptor_,
      Location::default_instance_,
      Location_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Location));
  Area_descriptor_ = file->message_type(1);
  static const int Area_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area, northeast_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area, southwest_),
  };
  Area_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Area_descriptor_,
      Area::default_instance_,
      Area_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Area));
  Time_descriptor_ = file->message_type(2);
  static const int Time_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, timestamp_),
  };
  Time_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Time_descriptor_,
      Time::default_instance_,
      Time_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Time, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Time));
  Comment_descriptor_ = file->message_type(3);
  static const int Comment_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Comment, content_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Comment, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Comment, uid_),
  };
  Comment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Comment_descriptor_,
      Comment::default_instance_,
      Comment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Comment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Comment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Comment));
  Currency_descriptor_ = file->message_type(4);
  static const int Currency_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Currency, amount_),
  };
  Currency_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Currency_descriptor_,
      Currency::default_instance_,
      Currency_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Currency, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Currency, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Currency));
  Error_descriptor_ = file->message_type(5);
  static const int Error_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, message_),
  };
  Error_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Error_descriptor_,
      Error::default_instance_,
      Error_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Error));
  User_descriptor_ = file->message_type(6);
  static const int User_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, uniquename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, jointime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, prefertypes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, friends_),
  };
  User_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      User_descriptor_,
      User::default_instance_,
      User_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(User));
  Restaurant_descriptor_ = file->message_type(7);
  static const int Restaurant_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Restaurant, location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Restaurant, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Restaurant, rid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Restaurant, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Restaurant, rating_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Restaurant, averageexpense_),
  };
  Restaurant_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Restaurant_descriptor_,
      Restaurant::default_instance_,
      Restaurant_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Restaurant, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Restaurant, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Restaurant));
  RestaurantList_descriptor_ = file->message_type(8);
  static const int RestaurantList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RestaurantList, restaurants_),
  };
  RestaurantList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RestaurantList_descriptor_,
      RestaurantList::default_instance_,
      RestaurantList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RestaurantList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RestaurantList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RestaurantList));
  CommentList_descriptor_ = file->message_type(9);
  static const int CommentList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommentList, comments_),
  };
  CommentList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CommentList_descriptor_,
      CommentList::default_instance_,
      CommentList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommentList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommentList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CommentList));
  RestaurantType_descriptor_ = file->message_type(10);
  static const int RestaurantType_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RestaurantType, tid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RestaurantType, name_),
  };
  RestaurantType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RestaurantType_descriptor_,
      RestaurantType::default_instance_,
      RestaurantType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RestaurantType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RestaurantType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RestaurantType));
  Query_descriptor_ = file->message_type(11);
  static const int Query_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, area_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, rid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, msg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, image_),
  };
  Query_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Query_descriptor_,
      Query::default_instance_,
      Query_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Query));
  DMService_descriptor_ = file->service(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_MapProtocol_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Location_descriptor_, &Location::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Area_descriptor_, &Area::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Time_descriptor_, &Time::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Comment_descriptor_, &Comment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Currency_descriptor_, &Currency::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Error_descriptor_, &Error::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    User_descriptor_, &User::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Restaurant_descriptor_, &Restaurant::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RestaurantList_descriptor_, &RestaurantList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CommentList_descriptor_, &CommentList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RestaurantType_descriptor_, &RestaurantType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Query_descriptor_, &Query::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_MapProtocol_2eproto() {
  delete Location::default_instance_;
  delete Location_reflection_;
  delete Area::default_instance_;
  delete Area_reflection_;
  delete Time::default_instance_;
  delete Time_reflection_;
  delete Comment::default_instance_;
  delete Comment_reflection_;
  delete Currency::default_instance_;
  delete Currency_reflection_;
  delete Error::default_instance_;
  delete Error_reflection_;
  delete User::default_instance_;
  delete User_reflection_;
  delete Restaurant::default_instance_;
  delete Restaurant_reflection_;
  delete RestaurantList::default_instance_;
  delete RestaurantList_reflection_;
  delete CommentList::default_instance_;
  delete CommentList_reflection_;
  delete RestaurantType::default_instance_;
  delete RestaurantType_reflection_;
  delete Query::default_instance_;
  delete Query_reflection_;
}

void protobuf_AddDesc_MapProtocol_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021MapProtocol.proto\022\016ProtocolBuffer\"/\n\010L"
    "ocation\022\020\n\010latitude\030\001 \002(\001\022\021\n\tlongitude\030\002"
    " \002(\001\"`\n\004Area\022+\n\tnortheast\030\001 \002(\0132\030.Protoc"
    "olBuffer.Location\022+\n\tsouthwest\030\002 \002(\0132\030.P"
    "rotocolBuffer.Location\"\031\n\004Time\022\021\n\ttimeSt"
    "amp\030\001 \002(\t\"P\n\007Comment\022\017\n\007content\030\001 \002(\t\022\'\n"
    "\ttimeStamp\030\002 \002(\0132\024.ProtocolBuffer.Time\022\013"
    "\n\003UID\030\003 \002(\r\"\032\n\010Currency\022\016\n\006amount\030\001 \002(\001\""
    "\030\n\005Error\022\017\n\007message\030\001 \002(\t\"\225\001\n\004User\022\013\n\003UI"
    "D\030\001 \002(\r\022\022\n\nuniqueName\030\002 \002(\t\022&\n\010joinTime\030"
    "\003 \002(\0132\024.ProtocolBuffer.Time\0223\n\013preferTyp"
    "es\030\004 \003(\0132\036.ProtocolBuffer.RestaurantType"
    "\022\017\n\007friends\030\005 \003(\r\"\303\001\n\nRestaurant\022*\n\010loca"
    "tion\030\001 \002(\0132\030.ProtocolBuffer.Location\022\014\n\004"
    "name\030\002 \002(\t\022\013\n\003RID\030\003 \002(\r\022,\n\004type\030\004 \002(\0132\036."
    "ProtocolBuffer.RestaurantType\022\016\n\006Rating\030"
    "\005 \002(\r\0220\n\016averageExpense\030\006 \002(\0132\030.Protocol"
    "Buffer.Currency\"A\n\016RestaurantList\022/\n\013res"
    "taurants\030\001 \003(\0132\032.ProtocolBuffer.Restaura"
    "nt\"8\n\013CommentList\022)\n\010comments\030\001 \003(\0132\027.Pr"
    "otocolBuffer.Comment\"+\n\016RestaurantType\022\013"
    "\n\003TID\030\001 \002(\r\022\014\n\004name\030\002 \002(\t\"\237\001\n\005Query\022\"\n\004a"
    "rea\030\001 \001(\0132\024.ProtocolBuffer.Area\022\r\n\005level"
    "\030\002 \001(\r\022\"\n\004time\030\003 \001(\0132\024.ProtocolBuffer.Ti"
    "me\022\013\n\003RID\030\004 \001(\r\022\013\n\003UID\030\005 \001(\r\022\t\n\001n\030\006 \001(\r\022"
    "\013\n\003msg\030\007 \001(\t\022\r\n\005image\030\010 \001(\0142\347\003\n\tDMServic"
    "e\022G\n\016GetRestaurants\022\025.ProtocolBuffer.Que"
    "ry\032\036.ProtocolBuffer.RestaurantList\022T\n\036Ge"
    "tLastestCommentsOfRestaurant\022\025.ProtocolB"
    "uffer.Query\032\033.ProtocolBuffer.CommentList"
    "\022N\n\030GetLastestCommentsByUser\022\025.ProtocolB"
    "uffer.Query\032\033.ProtocolBuffer.CommentList"
    "\022L\n\026GetCommentsOfUserSince\022\025.ProtocolBuf"
    "fer.Query\032\033.ProtocolBuffer.CommentList\022R"
    "\n\034GetCommentsOfRestaurantSince\022\025.Protoco"
    "lBuffer.Query\032\033.ProtocolBuffer.CommentLi"
    "st\022I\n\027AddCommentForRestaurant\022\025.Protocol"
    "Buffer.Query\032\027.ProtocolBuffer.CommentB\002H"
    "\001", 1521);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "MapProtocol.proto", &protobuf_RegisterTypes);
  Location::default_instance_ = new Location();
  Area::default_instance_ = new Area();
  Time::default_instance_ = new Time();
  Comment::default_instance_ = new Comment();
  Currency::default_instance_ = new Currency();
  Error::default_instance_ = new Error();
  User::default_instance_ = new User();
  Restaurant::default_instance_ = new Restaurant();
  RestaurantList::default_instance_ = new RestaurantList();
  CommentList::default_instance_ = new CommentList();
  RestaurantType::default_instance_ = new RestaurantType();
  Query::default_instance_ = new Query();
  Location::default_instance_->InitAsDefaultInstance();
  Area::default_instance_->InitAsDefaultInstance();
  Time::default_instance_->InitAsDefaultInstance();
  Comment::default_instance_->InitAsDefaultInstance();
  Currency::default_instance_->InitAsDefaultInstance();
  Error::default_instance_->InitAsDefaultInstance();
  User::default_instance_->InitAsDefaultInstance();
  Restaurant::default_instance_->InitAsDefaultInstance();
  RestaurantList::default_instance_->InitAsDefaultInstance();
  CommentList::default_instance_->InitAsDefaultInstance();
  RestaurantType::default_instance_->InitAsDefaultInstance();
  Query::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_MapProtocol_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_MapProtocol_2eproto {
  StaticDescriptorInitializer_MapProtocol_2eproto() {
    protobuf_AddDesc_MapProtocol_2eproto();
  }
} static_descriptor_initializer_MapProtocol_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Location::kLatitudeFieldNumber;
const int Location::kLongitudeFieldNumber;
#endif  // !_MSC_VER

Location::Location() {
  SharedCtor();
}

void Location::InitAsDefaultInstance() {
}

Location::Location(const Location& from) {
  SharedCtor();
  MergeFrom(from);
}

void Location::SharedCtor() {
  _cached_size_ = 0;
  latitude_ = 0;
  longitude_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Location::~Location() {
  SharedDtor();
}

void Location::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Location::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Location_descriptor_;
}

const Location& Location::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Location* Location::default_instance_ = NULL;

Location* Location::New() const {
  return new Location;
}

void Location::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    latitude_ = 0;
    longitude_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Location::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double latitude = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &latitude_));
        _set_bit(0);
        if (input->ExpectTag(17)) goto parse_longitude;
        break;
      }
      
      // required double longitude = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
       parse_longitude:
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &longitude_));
        _set_bit(1);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Location::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Location::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required double latitude = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->latitude(), output);
  }
  
  // required double longitude = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->longitude(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Location::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double latitude = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->latitude(), target);
  }
  
  // required double longitude = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->longitude(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Location::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double latitude = 1;
    if (has_latitude()) {
      total_size += 1 + 8;
    }
    
    // required double longitude = 2;
    if (has_longitude()) {
      total_size += 1 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Location::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Location* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Location*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Location::MergeFrom(const Location& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_latitude(from.latitude());
    }
    if (from._has_bit(1)) {
      set_longitude(from.longitude());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Location::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Location::CopyFrom(const Location& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Location::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Location::Swap(Location* other) {
  if (other != this) {
    std::swap(latitude_, other->latitude_);
    std::swap(longitude_, other->longitude_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Location::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Location_descriptor_;
  metadata.reflection = Location_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Area::kNortheastFieldNumber;
const int Area::kSouthwestFieldNumber;
#endif  // !_MSC_VER

Area::Area() {
  SharedCtor();
}

void Area::InitAsDefaultInstance() {
  northeast_ = const_cast< ::ProtocolBuffer::Location*>(&::ProtocolBuffer::Location::default_instance());
  southwest_ = const_cast< ::ProtocolBuffer::Location*>(&::ProtocolBuffer::Location::default_instance());
}

Area::Area(const Area& from) {
  SharedCtor();
  MergeFrom(from);
}

void Area::SharedCtor() {
  _cached_size_ = 0;
  northeast_ = NULL;
  southwest_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Area::~Area() {
  SharedDtor();
}

void Area::SharedDtor() {
  if (this != default_instance_) {
    delete northeast_;
    delete southwest_;
  }
}

const ::google::protobuf::Descriptor* Area::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Area_descriptor_;
}

const Area& Area::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Area* Area::default_instance_ = NULL;

Area* Area::New() const {
  return new Area;
}

void Area::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (northeast_ != NULL) northeast_->::ProtocolBuffer::Location::Clear();
    }
    if (_has_bit(1)) {
      if (southwest_ != NULL) southwest_->::ProtocolBuffer::Location::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Area::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtocolBuffer.Location northeast = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_northeast()));
        if (input->ExpectTag(18)) goto parse_southwest;
        break;
      }
      
      // required .ProtocolBuffer.Location southwest = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_southwest:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_southwest()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Area::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Area::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .ProtocolBuffer.Location northeast = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->northeast(), output);
  }
  
  // required .ProtocolBuffer.Location southwest = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      2, this->southwest(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Area::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ProtocolBuffer.Location northeast = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->northeast(), target);
  }
  
  // required .ProtocolBuffer.Location southwest = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->southwest(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Area::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtocolBuffer.Location northeast = 1;
    if (has_northeast()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->northeast());
    }
    
    // required .ProtocolBuffer.Location southwest = 2;
    if (has_southwest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->southwest());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Area::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Area* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Area*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Area::MergeFrom(const Area& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_northeast()->::ProtocolBuffer::Location::MergeFrom(from.northeast());
    }
    if (from._has_bit(1)) {
      mutable_southwest()->::ProtocolBuffer::Location::MergeFrom(from.southwest());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Area::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Area::CopyFrom(const Area& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Area::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_northeast()) {
    if (!this->northeast().IsInitialized()) return false;
  }
  if (has_southwest()) {
    if (!this->southwest().IsInitialized()) return false;
  }
  return true;
}

void Area::Swap(Area* other) {
  if (other != this) {
    std::swap(northeast_, other->northeast_);
    std::swap(southwest_, other->southwest_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Area::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Area_descriptor_;
  metadata.reflection = Area_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Time::_default_timestamp_;
#ifndef _MSC_VER
const int Time::kTimeStampFieldNumber;
#endif  // !_MSC_VER

Time::Time() {
  SharedCtor();
}

void Time::InitAsDefaultInstance() {
}

Time::Time(const Time& from) {
  SharedCtor();
  MergeFrom(from);
}

void Time::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = const_cast< ::std::string*>(&_default_timestamp_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Time::~Time() {
  SharedDtor();
}

void Time::SharedDtor() {
  if (timestamp_ != &_default_timestamp_) {
    delete timestamp_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Time::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Time_descriptor_;
}

const Time& Time::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Time* Time::default_instance_ = NULL;

Time* Time::New() const {
  return new Time;
}

void Time::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (timestamp_ != &_default_timestamp_) {
        timestamp_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Time::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string timeStamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_timestamp()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->timestamp().data(), this->timestamp().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Time::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Time::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required string timeStamp = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->timestamp().data(), this->timestamp().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->timestamp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Time::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string timeStamp = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->timestamp().data(), this->timestamp().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->timestamp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Time::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string timeStamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->timestamp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Time::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Time* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Time*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Time::MergeFrom(const Time& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Time::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Time::CopyFrom(const Time& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Time::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Time::Swap(Time* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Time::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Time_descriptor_;
  metadata.reflection = Time_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Comment::_default_content_;
#ifndef _MSC_VER
const int Comment::kContentFieldNumber;
const int Comment::kTimeStampFieldNumber;
const int Comment::kUIDFieldNumber;
#endif  // !_MSC_VER

Comment::Comment() {
  SharedCtor();
}

void Comment::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::ProtocolBuffer::Time*>(&::ProtocolBuffer::Time::default_instance());
}

Comment::Comment(const Comment& from) {
  SharedCtor();
  MergeFrom(from);
}

void Comment::SharedCtor() {
  _cached_size_ = 0;
  content_ = const_cast< ::std::string*>(&_default_content_);
  timestamp_ = NULL;
  uid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Comment::~Comment() {
  SharedDtor();
}

void Comment::SharedDtor() {
  if (content_ != &_default_content_) {
    delete content_;
  }
  if (this != default_instance_) {
    delete timestamp_;
  }
}

const ::google::protobuf::Descriptor* Comment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Comment_descriptor_;
}

const Comment& Comment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Comment* Comment::default_instance_ = NULL;

Comment* Comment::New() const {
  return new Comment;
}

void Comment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (content_ != &_default_content_) {
        content_->clear();
      }
    }
    if (_has_bit(1)) {
      if (timestamp_ != NULL) timestamp_->::ProtocolBuffer::Time::Clear();
    }
    uid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Comment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string content = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_content()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->content().data(), this->content().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(18)) goto parse_timeStamp;
        break;
      }
      
      // required .ProtocolBuffer.Time timeStamp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_timeStamp:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_timestamp()));
        if (input->ExpectTag(24)) goto parse_UID;
        break;
      }
      
      // required uint32 UID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_UID:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &uid_));
        _set_bit(2);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Comment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Comment::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required string content = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->content().data(), this->content().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->content(), output);
  }
  
  // required .ProtocolBuffer.Time timeStamp = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      2, this->timestamp(), output);
  }
  
  // required uint32 UID = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->uid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Comment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string content = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->content().data(), this->content().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->content(), target);
  }
  
  // required .ProtocolBuffer.Time timeStamp = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->timestamp(), target);
  }
  
  // required uint32 UID = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->uid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Comment::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string content = 1;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }
    
    // required .ProtocolBuffer.Time timeStamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->timestamp());
    }
    
    // required uint32 UID = 3;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Comment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Comment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Comment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Comment::MergeFrom(const Comment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_content(from.content());
    }
    if (from._has_bit(1)) {
      mutable_timestamp()->::ProtocolBuffer::Time::MergeFrom(from.timestamp());
    }
    if (from._has_bit(2)) {
      set_uid(from.uid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Comment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Comment::CopyFrom(const Comment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Comment::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_timestamp()) {
    if (!this->timestamp().IsInitialized()) return false;
  }
  return true;
}

void Comment::Swap(Comment* other) {
  if (other != this) {
    std::swap(content_, other->content_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(uid_, other->uid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Comment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Comment_descriptor_;
  metadata.reflection = Comment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Currency::kAmountFieldNumber;
#endif  // !_MSC_VER

Currency::Currency() {
  SharedCtor();
}

void Currency::InitAsDefaultInstance() {
}

Currency::Currency(const Currency& from) {
  SharedCtor();
  MergeFrom(from);
}

void Currency::SharedCtor() {
  _cached_size_ = 0;
  amount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Currency::~Currency() {
  SharedDtor();
}

void Currency::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Currency::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Currency_descriptor_;
}

const Currency& Currency::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Currency* Currency::default_instance_ = NULL;

Currency* Currency::New() const {
  return new Currency;
}

void Currency::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    amount_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Currency::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double amount = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadDouble(
              input, &amount_));
        _set_bit(0);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Currency::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Currency::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required double amount = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->amount(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Currency::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double amount = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->amount(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Currency::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double amount = 1;
    if (has_amount()) {
      total_size += 1 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Currency::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Currency* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Currency*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Currency::MergeFrom(const Currency& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_amount(from.amount());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Currency::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Currency::CopyFrom(const Currency& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Currency::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Currency::Swap(Currency* other) {
  if (other != this) {
    std::swap(amount_, other->amount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Currency::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Currency_descriptor_;
  metadata.reflection = Currency_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Error::_default_message_;
#ifndef _MSC_VER
const int Error::kMessageFieldNumber;
#endif  // !_MSC_VER

Error::Error() {
  SharedCtor();
}

void Error::InitAsDefaultInstance() {
}

Error::Error(const Error& from) {
  SharedCtor();
  MergeFrom(from);
}

void Error::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&_default_message_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Error::~Error() {
  SharedDtor();
}

void Error::SharedDtor() {
  if (message_ != &_default_message_) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Error::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Error_descriptor_;
}

const Error& Error::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Error* Error::default_instance_ = NULL;

Error* Error::New() const {
  return new Error;
}

void Error::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (message_ != &_default_message_) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string message = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_message()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->message().data(), this->message().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Error::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required string message = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->message(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Error::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string message = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Error::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Error::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Error* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Error*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Error::MergeFrom(const Error& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Error::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Error::CopyFrom(const Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Error::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Error::Swap(Error* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Error::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Error_descriptor_;
  metadata.reflection = Error_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string User::_default_uniquename_;
#ifndef _MSC_VER
const int User::kUIDFieldNumber;
const int User::kUniqueNameFieldNumber;
const int User::kJoinTimeFieldNumber;
const int User::kPreferTypesFieldNumber;
const int User::kFriendsFieldNumber;
#endif  // !_MSC_VER

User::User() {
  SharedCtor();
}

void User::InitAsDefaultInstance() {
  jointime_ = const_cast< ::ProtocolBuffer::Time*>(&::ProtocolBuffer::Time::default_instance());
}

User::User(const User& from) {
  SharedCtor();
  MergeFrom(from);
}

void User::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0u;
  uniquename_ = const_cast< ::std::string*>(&_default_uniquename_);
  jointime_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

User::~User() {
  SharedDtor();
}

void User::SharedDtor() {
  if (uniquename_ != &_default_uniquename_) {
    delete uniquename_;
  }
  if (this != default_instance_) {
    delete jointime_;
  }
}

const ::google::protobuf::Descriptor* User::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return User_descriptor_;
}

const User& User::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

User* User::default_instance_ = NULL;

User* User::New() const {
  return new User;
}

void User::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0u;
    if (_has_bit(1)) {
      if (uniquename_ != &_default_uniquename_) {
        uniquename_->clear();
      }
    }
    if (_has_bit(2)) {
      if (jointime_ != NULL) jointime_->::ProtocolBuffer::Time::Clear();
    }
  }
  prefertypes_.Clear();
  friends_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool User::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 UID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &uid_));
        _set_bit(0);
        if (input->ExpectTag(18)) goto parse_uniqueName;
        break;
      }
      
      // required string uniqueName = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_uniqueName:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_uniquename()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->uniquename().data(), this->uniquename().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(26)) goto parse_joinTime;
        break;
      }
      
      // required .ProtocolBuffer.Time joinTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_joinTime:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_jointime()));
        if (input->ExpectTag(34)) goto parse_preferTypes;
        break;
      }
      
      // repeated .ProtocolBuffer.RestaurantType preferTypes = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_preferTypes:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_prefertypes()));
        if (input->ExpectTag(34)) goto parse_preferTypes;
        if (input->ExpectTag(40)) goto parse_friends;
        break;
      }
      
      // repeated uint32 friends = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_friends:
        ::google::protobuf::uint32 value;
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &value));
        add_friends(value);
        if (input->ExpectTag(40)) goto parse_friends;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void User::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    User::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required uint32 UID = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uid(), output);
  }
  
  // required string uniqueName = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uniquename().data(), this->uniquename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->uniquename(), output);
  }
  
  // required .ProtocolBuffer.Time joinTime = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      3, this->jointime(), output);
  }
  
  // repeated .ProtocolBuffer.RestaurantType preferTypes = 4;
  for (int i = 0; i < this->prefertypes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      4, this->prefertypes(i), output);
  }
  
  // repeated uint32 friends = 5;
  for (int i = 0; i < this->friends_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->friends(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* User::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 UID = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uid(), target);
  }
  
  // required string uniqueName = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uniquename().data(), this->uniquename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->uniquename(), target);
  }
  
  // required .ProtocolBuffer.Time joinTime = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->jointime(), target);
  }
  
  // repeated .ProtocolBuffer.RestaurantType preferTypes = 4;
  for (int i = 0; i < this->prefertypes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->prefertypes(i), target);
  }
  
  // repeated uint32 friends = 5;
  for (int i = 0; i < this->friends_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(5, this->friends(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int User::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 UID = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }
    
    // required string uniqueName = 2;
    if (has_uniquename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uniquename());
    }
    
    // required .ProtocolBuffer.Time joinTime = 3;
    if (has_jointime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->jointime());
    }
    
  }
  // repeated .ProtocolBuffer.RestaurantType preferTypes = 4;
  total_size += 1 * this->prefertypes_size();
  for (int i = 0; i < this->prefertypes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->prefertypes(i));
  }
  
  // repeated uint32 friends = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->friends_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->friends(i));
    }
    total_size += 1 * this->friends_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void User::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const User* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const User*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void User::MergeFrom(const User& from) {
  GOOGLE_CHECK_NE(&from, this);
  prefertypes_.MergeFrom(from.prefertypes_);
  friends_.MergeFrom(from.friends_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_uid(from.uid());
    }
    if (from._has_bit(1)) {
      set_uniquename(from.uniquename());
    }
    if (from._has_bit(2)) {
      mutable_jointime()->::ProtocolBuffer::Time::MergeFrom(from.jointime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void User::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void User::CopyFrom(const User& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool User::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_jointime()) {
    if (!this->jointime().IsInitialized()) return false;
  }
  for (int i = 0; i < prefertypes_size(); i++) {
    if (!this->prefertypes(i).IsInitialized()) return false;
  }
  return true;
}

void User::Swap(User* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(uniquename_, other->uniquename_);
    std::swap(jointime_, other->jointime_);
    prefertypes_.Swap(&other->prefertypes_);
    friends_.Swap(&other->friends_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata User::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = User_descriptor_;
  metadata.reflection = User_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Restaurant::_default_name_;
#ifndef _MSC_VER
const int Restaurant::kLocationFieldNumber;
const int Restaurant::kNameFieldNumber;
const int Restaurant::kRIDFieldNumber;
const int Restaurant::kTypeFieldNumber;
const int Restaurant::kRatingFieldNumber;
const int Restaurant::kAverageExpenseFieldNumber;
#endif  // !_MSC_VER

Restaurant::Restaurant() {
  SharedCtor();
}

void Restaurant::InitAsDefaultInstance() {
  location_ = const_cast< ::ProtocolBuffer::Location*>(&::ProtocolBuffer::Location::default_instance());
  type_ = const_cast< ::ProtocolBuffer::RestaurantType*>(&::ProtocolBuffer::RestaurantType::default_instance());
  averageexpense_ = const_cast< ::ProtocolBuffer::Currency*>(&::ProtocolBuffer::Currency::default_instance());
}

Restaurant::Restaurant(const Restaurant& from) {
  SharedCtor();
  MergeFrom(from);
}

void Restaurant::SharedCtor() {
  _cached_size_ = 0;
  location_ = NULL;
  name_ = const_cast< ::std::string*>(&_default_name_);
  rid_ = 0u;
  type_ = NULL;
  rating_ = 0u;
  averageexpense_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Restaurant::~Restaurant() {
  SharedDtor();
}

void Restaurant::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (this != default_instance_) {
    delete location_;
    delete type_;
    delete averageexpense_;
  }
}

const ::google::protobuf::Descriptor* Restaurant::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Restaurant_descriptor_;
}

const Restaurant& Restaurant::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Restaurant* Restaurant::default_instance_ = NULL;

Restaurant* Restaurant::New() const {
  return new Restaurant;
}

void Restaurant::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (location_ != NULL) location_->::ProtocolBuffer::Location::Clear();
    }
    if (_has_bit(1)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    rid_ = 0u;
    if (_has_bit(3)) {
      if (type_ != NULL) type_->::ProtocolBuffer::RestaurantType::Clear();
    }
    rating_ = 0u;
    if (_has_bit(5)) {
      if (averageexpense_ != NULL) averageexpense_->::ProtocolBuffer::Currency::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Restaurant::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ProtocolBuffer.Location location = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_location()));
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_name:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_name()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->name().data(), this->name().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(24)) goto parse_RID;
        break;
      }
      
      // required uint32 RID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_RID:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &rid_));
        _set_bit(2);
        if (input->ExpectTag(34)) goto parse_type;
        break;
      }
      
      // required .ProtocolBuffer.RestaurantType type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_type:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_type()));
        if (input->ExpectTag(40)) goto parse_Rating;
        break;
      }
      
      // required uint32 Rating = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_Rating:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &rating_));
        _set_bit(4);
        if (input->ExpectTag(50)) goto parse_averageExpense;
        break;
      }
      
      // required .ProtocolBuffer.Currency averageExpense = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_averageExpense:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_averageexpense()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Restaurant::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Restaurant::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .ProtocolBuffer.Location location = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->location(), output);
  }
  
  // required string name = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  // required uint32 RID = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->rid(), output);
  }
  
  // required .ProtocolBuffer.RestaurantType type = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      4, this->type(), output);
  }
  
  // required uint32 Rating = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->rating(), output);
  }
  
  // required .ProtocolBuffer.Currency averageExpense = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      6, this->averageexpense(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Restaurant::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ProtocolBuffer.Location location = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->location(), target);
  }
  
  // required string name = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }
  
  // required uint32 RID = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->rid(), target);
  }
  
  // required .ProtocolBuffer.RestaurantType type = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->type(), target);
  }
  
  // required uint32 Rating = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->rating(), target);
  }
  
  // required .ProtocolBuffer.Currency averageExpense = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->averageexpense(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Restaurant::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ProtocolBuffer.Location location = 1;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }
    
    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required uint32 RID = 3;
    if (has_rid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rid());
    }
    
    // required .ProtocolBuffer.RestaurantType type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->type());
    }
    
    // required uint32 Rating = 5;
    if (has_rating()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rating());
    }
    
    // required .ProtocolBuffer.Currency averageExpense = 6;
    if (has_averageexpense()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->averageexpense());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Restaurant::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Restaurant* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Restaurant*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Restaurant::MergeFrom(const Restaurant& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_location()->::ProtocolBuffer::Location::MergeFrom(from.location());
    }
    if (from._has_bit(1)) {
      set_name(from.name());
    }
    if (from._has_bit(2)) {
      set_rid(from.rid());
    }
    if (from._has_bit(3)) {
      mutable_type()->::ProtocolBuffer::RestaurantType::MergeFrom(from.type());
    }
    if (from._has_bit(4)) {
      set_rating(from.rating());
    }
    if (from._has_bit(5)) {
      mutable_averageexpense()->::ProtocolBuffer::Currency::MergeFrom(from.averageexpense());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Restaurant::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Restaurant::CopyFrom(const Restaurant& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Restaurant::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  
  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  if (has_type()) {
    if (!this->type().IsInitialized()) return false;
  }
  if (has_averageexpense()) {
    if (!this->averageexpense().IsInitialized()) return false;
  }
  return true;
}

void Restaurant::Swap(Restaurant* other) {
  if (other != this) {
    std::swap(location_, other->location_);
    std::swap(name_, other->name_);
    std::swap(rid_, other->rid_);
    std::swap(type_, other->type_);
    std::swap(rating_, other->rating_);
    std::swap(averageexpense_, other->averageexpense_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Restaurant::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Restaurant_descriptor_;
  metadata.reflection = Restaurant_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RestaurantList::kRestaurantsFieldNumber;
#endif  // !_MSC_VER

RestaurantList::RestaurantList() {
  SharedCtor();
}

void RestaurantList::InitAsDefaultInstance() {
}

RestaurantList::RestaurantList(const RestaurantList& from) {
  SharedCtor();
  MergeFrom(from);
}

void RestaurantList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RestaurantList::~RestaurantList() {
  SharedDtor();
}

void RestaurantList::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* RestaurantList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RestaurantList_descriptor_;
}

const RestaurantList& RestaurantList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

RestaurantList* RestaurantList::default_instance_ = NULL;

RestaurantList* RestaurantList::New() const {
  return new RestaurantList;
}

void RestaurantList::Clear() {
  restaurants_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RestaurantList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ProtocolBuffer.Restaurant restaurants = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_restaurants:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_restaurants()));
        if (input->ExpectTag(10)) goto parse_restaurants;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RestaurantList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    RestaurantList::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // repeated .ProtocolBuffer.Restaurant restaurants = 1;
  for (int i = 0; i < this->restaurants_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->restaurants(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RestaurantList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ProtocolBuffer.Restaurant restaurants = 1;
  for (int i = 0; i < this->restaurants_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->restaurants(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RestaurantList::ByteSize() const {
  int total_size = 0;
  
  // repeated .ProtocolBuffer.Restaurant restaurants = 1;
  total_size += 1 * this->restaurants_size();
  for (int i = 0; i < this->restaurants_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->restaurants(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void RestaurantList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RestaurantList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RestaurantList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RestaurantList::MergeFrom(const RestaurantList& from) {
  GOOGLE_CHECK_NE(&from, this);
  restaurants_.MergeFrom(from.restaurants_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RestaurantList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RestaurantList::CopyFrom(const RestaurantList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RestaurantList::IsInitialized() const {
  
  for (int i = 0; i < restaurants_size(); i++) {
    if (!this->restaurants(i).IsInitialized()) return false;
  }
  return true;
}

void RestaurantList::Swap(RestaurantList* other) {
  if (other != this) {
    restaurants_.Swap(&other->restaurants_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RestaurantList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RestaurantList_descriptor_;
  metadata.reflection = RestaurantList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CommentList::kCommentsFieldNumber;
#endif  // !_MSC_VER

CommentList::CommentList() {
  SharedCtor();
}

void CommentList::InitAsDefaultInstance() {
}

CommentList::CommentList(const CommentList& from) {
  SharedCtor();
  MergeFrom(from);
}

void CommentList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommentList::~CommentList() {
  SharedDtor();
}

void CommentList::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* CommentList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CommentList_descriptor_;
}

const CommentList& CommentList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

CommentList* CommentList::default_instance_ = NULL;

CommentList* CommentList::New() const {
  return new CommentList;
}

void CommentList::Clear() {
  comments_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CommentList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ProtocolBuffer.Comment comments = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_comments:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_comments()));
        if (input->ExpectTag(10)) goto parse_comments;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CommentList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    CommentList::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // repeated .ProtocolBuffer.Comment comments = 1;
  for (int i = 0; i < this->comments_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->comments(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CommentList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ProtocolBuffer.Comment comments = 1;
  for (int i = 0; i < this->comments_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->comments(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CommentList::ByteSize() const {
  int total_size = 0;
  
  // repeated .ProtocolBuffer.Comment comments = 1;
  total_size += 1 * this->comments_size();
  for (int i = 0; i < this->comments_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->comments(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void CommentList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CommentList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CommentList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CommentList::MergeFrom(const CommentList& from) {
  GOOGLE_CHECK_NE(&from, this);
  comments_.MergeFrom(from.comments_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CommentList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CommentList::CopyFrom(const CommentList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommentList::IsInitialized() const {
  
  for (int i = 0; i < comments_size(); i++) {
    if (!this->comments(i).IsInitialized()) return false;
  }
  return true;
}

void CommentList::Swap(CommentList* other) {
  if (other != this) {
    comments_.Swap(&other->comments_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CommentList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CommentList_descriptor_;
  metadata.reflection = CommentList_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string RestaurantType::_default_name_;
#ifndef _MSC_VER
const int RestaurantType::kTIDFieldNumber;
const int RestaurantType::kNameFieldNumber;
#endif  // !_MSC_VER

RestaurantType::RestaurantType() {
  SharedCtor();
}

void RestaurantType::InitAsDefaultInstance() {
}

RestaurantType::RestaurantType(const RestaurantType& from) {
  SharedCtor();
  MergeFrom(from);
}

void RestaurantType::SharedCtor() {
  _cached_size_ = 0;
  tid_ = 0u;
  name_ = const_cast< ::std::string*>(&_default_name_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RestaurantType::~RestaurantType() {
  SharedDtor();
}

void RestaurantType::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* RestaurantType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RestaurantType_descriptor_;
}

const RestaurantType& RestaurantType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

RestaurantType* RestaurantType::default_instance_ = NULL;

RestaurantType* RestaurantType::New() const {
  return new RestaurantType;
}

void RestaurantType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tid_ = 0u;
    if (_has_bit(1)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RestaurantType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 TID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &tid_));
        _set_bit(0);
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_name:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_name()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->name().data(), this->name().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RestaurantType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    RestaurantType::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required uint32 TID = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->tid(), output);
  }
  
  // required string name = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RestaurantType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 TID = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->tid(), target);
  }
  
  // required string name = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RestaurantType::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 TID = 1;
    if (has_tid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tid());
    }
    
    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void RestaurantType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RestaurantType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RestaurantType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RestaurantType::MergeFrom(const RestaurantType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_tid(from.tid());
    }
    if (from._has_bit(1)) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RestaurantType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RestaurantType::CopyFrom(const RestaurantType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RestaurantType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void RestaurantType::Swap(RestaurantType* other) {
  if (other != this) {
    std::swap(tid_, other->tid_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RestaurantType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RestaurantType_descriptor_;
  metadata.reflection = RestaurantType_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Query::_default_msg_;
const ::std::string Query::_default_image_;
#ifndef _MSC_VER
const int Query::kAreaFieldNumber;
const int Query::kLevelFieldNumber;
const int Query::kTimeFieldNumber;
const int Query::kRIDFieldNumber;
const int Query::kUIDFieldNumber;
const int Query::kNFieldNumber;
const int Query::kMsgFieldNumber;
const int Query::kImageFieldNumber;
#endif  // !_MSC_VER

Query::Query() {
  SharedCtor();
}

void Query::InitAsDefaultInstance() {
  area_ = const_cast< ::ProtocolBuffer::Area*>(&::ProtocolBuffer::Area::default_instance());
  time_ = const_cast< ::ProtocolBuffer::Time*>(&::ProtocolBuffer::Time::default_instance());
}

Query::Query(const Query& from) {
  SharedCtor();
  MergeFrom(from);
}

void Query::SharedCtor() {
  _cached_size_ = 0;
  area_ = NULL;
  level_ = 0u;
  time_ = NULL;
  rid_ = 0u;
  uid_ = 0u;
  n_ = 0u;
  msg_ = const_cast< ::std::string*>(&_default_msg_);
  image_ = const_cast< ::std::string*>(&_default_image_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Query::~Query() {
  SharedDtor();
}

void Query::SharedDtor() {
  if (msg_ != &_default_msg_) {
    delete msg_;
  }
  if (image_ != &_default_image_) {
    delete image_;
  }
  if (this != default_instance_) {
    delete area_;
    delete time_;
  }
}

const ::google::protobuf::Descriptor* Query::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Query_descriptor_;
}

const Query& Query::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapProtocol_2eproto();  return *default_instance_;
}

Query* Query::default_instance_ = NULL;

Query* Query::New() const {
  return new Query;
}

void Query::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (area_ != NULL) area_->::ProtocolBuffer::Area::Clear();
    }
    level_ = 0u;
    if (_has_bit(2)) {
      if (time_ != NULL) time_->::ProtocolBuffer::Time::Clear();
    }
    rid_ = 0u;
    uid_ = 0u;
    n_ = 0u;
    if (_has_bit(6)) {
      if (msg_ != &_default_msg_) {
        msg_->clear();
      }
    }
    if (_has_bit(7)) {
      if (image_ != &_default_image_) {
        image_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Query::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ProtocolBuffer.Area area = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_area()));
        if (input->ExpectTag(16)) goto parse_level;
        break;
      }
      
      // optional uint32 level = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_level:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &level_));
        _set_bit(1);
        if (input->ExpectTag(26)) goto parse_time;
        break;
      }
      
      // optional .ProtocolBuffer.Time time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_time:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_time()));
        if (input->ExpectTag(32)) goto parse_RID;
        break;
      }
      
      // optional uint32 RID = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_RID:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &rid_));
        _set_bit(3);
        if (input->ExpectTag(40)) goto parse_UID;
        break;
      }
      
      // optional uint32 UID = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_UID:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &uid_));
        _set_bit(4);
        if (input->ExpectTag(48)) goto parse_n;
        break;
      }
      
      // optional uint32 n = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_n:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &n_));
        _set_bit(5);
        if (input->ExpectTag(58)) goto parse_msg;
        break;
      }
      
      // optional string msg = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_msg:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_msg()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->msg().data(), this->msg().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(66)) goto parse_image;
        break;
      }
      
      // optional bytes image = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_image:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
              input, this->mutable_image()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Query::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Query::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional .ProtocolBuffer.Area area = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->area(), output);
  }
  
  // optional uint32 level = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->level(), output);
  }
  
  // optional .ProtocolBuffer.Time time = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      3, this->time(), output);
  }
  
  // optional uint32 RID = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->rid(), output);
  }
  
  // optional uint32 UID = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->uid(), output);
  }
  
  // optional uint32 n = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->n(), output);
  }
  
  // optional string msg = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msg().data(), this->msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->msg(), output);
  }
  
  // optional bytes image = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->image(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Query::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ProtocolBuffer.Area area = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->area(), target);
  }
  
  // optional uint32 level = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->level(), target);
  }
  
  // optional .ProtocolBuffer.Time time = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->time(), target);
  }
  
  // optional uint32 RID = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->rid(), target);
  }
  
  // optional uint32 UID = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->uid(), target);
  }
  
  // optional uint32 n = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->n(), target);
  }
  
  // optional string msg = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->msg().data(), this->msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->msg(), target);
  }
  
  // optional bytes image = 8;
  if (_has_bit(7)) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->image(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Query::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ProtocolBuffer.Area area = 1;
    if (has_area()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->area());
    }
    
    // optional uint32 level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }
    
    // optional .ProtocolBuffer.Time time = 3;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->time());
    }
    
    // optional uint32 RID = 4;
    if (has_rid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rid());
    }
    
    // optional uint32 UID = 5;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }
    
    // optional uint32 n = 6;
    if (has_n()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->n());
    }
    
    // optional string msg = 7;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }
    
    // optional bytes image = 8;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->image());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Query::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Query* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Query*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Query::MergeFrom(const Query& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_area()->::ProtocolBuffer::Area::MergeFrom(from.area());
    }
    if (from._has_bit(1)) {
      set_level(from.level());
    }
    if (from._has_bit(2)) {
      mutable_time()->::ProtocolBuffer::Time::MergeFrom(from.time());
    }
    if (from._has_bit(3)) {
      set_rid(from.rid());
    }
    if (from._has_bit(4)) {
      set_uid(from.uid());
    }
    if (from._has_bit(5)) {
      set_n(from.n());
    }
    if (from._has_bit(6)) {
      set_msg(from.msg());
    }
    if (from._has_bit(7)) {
      set_image(from.image());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Query::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Query::CopyFrom(const Query& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Query::IsInitialized() const {
  
  if (has_area()) {
    if (!this->area().IsInitialized()) return false;
  }
  if (has_time()) {
    if (!this->time().IsInitialized()) return false;
  }
  return true;
}

void Query::Swap(Query* other) {
  if (other != this) {
    std::swap(area_, other->area_);
    std::swap(level_, other->level_);
    std::swap(time_, other->time_);
    std::swap(rid_, other->rid_);
    std::swap(uid_, other->uid_);
    std::swap(n_, other->n_);
    std::swap(msg_, other->msg_);
    std::swap(image_, other->image_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Query::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Query_descriptor_;
  metadata.reflection = Query_reflection_;
  return metadata;
}


// ===================================================================

DMService::~DMService() {}

const ::google::protobuf::ServiceDescriptor* DMService::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DMService_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* DMService::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return DMService_descriptor_;
}

void DMService::GetRestaurants(::google::protobuf::RpcController* controller,
                         const ::ProtocolBuffer::Query*,
                         ::ProtocolBuffer::RestaurantList*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetRestaurants() not implemented.");
  done->Run();
}

void DMService::GetLastestCommentsOfRestaurant(::google::protobuf::RpcController* controller,
                         const ::ProtocolBuffer::Query*,
                         ::ProtocolBuffer::CommentList*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetLastestCommentsOfRestaurant() not implemented.");
  done->Run();
}

void DMService::GetLastestCommentsByUser(::google::protobuf::RpcController* controller,
                         const ::ProtocolBuffer::Query*,
                         ::ProtocolBuffer::CommentList*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetLastestCommentsByUser() not implemented.");
  done->Run();
}

void DMService::GetCommentsOfUserSince(::google::protobuf::RpcController* controller,
                         const ::ProtocolBuffer::Query*,
                         ::ProtocolBuffer::CommentList*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetCommentsOfUserSince() not implemented.");
  done->Run();
}

void DMService::GetCommentsOfRestaurantSince(::google::protobuf::RpcController* controller,
                         const ::ProtocolBuffer::Query*,
                         ::ProtocolBuffer::CommentList*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetCommentsOfRestaurantSince() not implemented.");
  done->Run();
}

void DMService::AddCommentForRestaurant(::google::protobuf::RpcController* controller,
                         const ::ProtocolBuffer::Query*,
                         ::ProtocolBuffer::Comment*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method AddCommentForRestaurant() not implemented.");
  done->Run();
}

void DMService::CallMethod(const ::google::protobuf::MethodDescriptor* method,
                             ::google::protobuf::RpcController* controller,
                             const ::google::protobuf::Message* request,
                             ::google::protobuf::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), DMService_descriptor_);
  switch(method->index()) {
    case 0:
      GetRestaurants(controller,
             ::google::protobuf::down_cast<const ::ProtocolBuffer::Query*>(request),
             ::google::protobuf::down_cast< ::ProtocolBuffer::RestaurantList*>(response),
             done);
      break;
    case 1:
      GetLastestCommentsOfRestaurant(controller,
             ::google::protobuf::down_cast<const ::ProtocolBuffer::Query*>(request),
             ::google::protobuf::down_cast< ::ProtocolBuffer::CommentList*>(response),
             done);
      break;
    case 2:
      GetLastestCommentsByUser(controller,
             ::google::protobuf::down_cast<const ::ProtocolBuffer::Query*>(request),
             ::google::protobuf::down_cast< ::ProtocolBuffer::CommentList*>(response),
             done);
      break;
    case 3:
      GetCommentsOfUserSince(controller,
             ::google::protobuf::down_cast<const ::ProtocolBuffer::Query*>(request),
             ::google::protobuf::down_cast< ::ProtocolBuffer::CommentList*>(response),
             done);
      break;
    case 4:
      GetCommentsOfRestaurantSince(controller,
             ::google::protobuf::down_cast<const ::ProtocolBuffer::Query*>(request),
             ::google::protobuf::down_cast< ::ProtocolBuffer::CommentList*>(response),
             done);
      break;
    case 5:
      AddCommentForRestaurant(controller,
             ::google::protobuf::down_cast<const ::ProtocolBuffer::Query*>(request),
             ::google::protobuf::down_cast< ::ProtocolBuffer::Comment*>(response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& DMService::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::ProtocolBuffer::Query::default_instance();
    case 1:
      return ::ProtocolBuffer::Query::default_instance();
    case 2:
      return ::ProtocolBuffer::Query::default_instance();
    case 3:
      return ::ProtocolBuffer::Query::default_instance();
    case 4:
      return ::ProtocolBuffer::Query::default_instance();
    case 5:
      return ::ProtocolBuffer::Query::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

const ::google::protobuf::Message& DMService::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::ProtocolBuffer::RestaurantList::default_instance();
    case 1:
      return ::ProtocolBuffer::CommentList::default_instance();
    case 2:
      return ::ProtocolBuffer::CommentList::default_instance();
    case 3:
      return ::ProtocolBuffer::CommentList::default_instance();
    case 4:
      return ::ProtocolBuffer::CommentList::default_instance();
    case 5:
      return ::ProtocolBuffer::Comment::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *reinterpret_cast< ::google::protobuf::Message*>(NULL);
  }
}

DMService_Stub::DMService_Stub(::google::protobuf::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
DMService_Stub::DMService_Stub(
    ::google::protobuf::RpcChannel* channel,
    ::google::protobuf::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::google::protobuf::Service::STUB_OWNS_CHANNEL) {}
DMService_Stub::~DMService_Stub() {
  if (owns_channel_) delete channel_;
}

void DMService_Stub::GetRestaurants(::google::protobuf::RpcController* controller,
                              const ::ProtocolBuffer::Query* request,
                              ::ProtocolBuffer::RestaurantList* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void DMService_Stub::GetLastestCommentsOfRestaurant(::google::protobuf::RpcController* controller,
                              const ::ProtocolBuffer::Query* request,
                              ::ProtocolBuffer::CommentList* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void DMService_Stub::GetLastestCommentsByUser(::google::protobuf::RpcController* controller,
                              const ::ProtocolBuffer::Query* request,
                              ::ProtocolBuffer::CommentList* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void DMService_Stub::GetCommentsOfUserSince(::google::protobuf::RpcController* controller,
                              const ::ProtocolBuffer::Query* request,
                              ::ProtocolBuffer::CommentList* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void DMService_Stub::GetCommentsOfRestaurantSince(::google::protobuf::RpcController* controller,
                              const ::ProtocolBuffer::Query* request,
                              ::ProtocolBuffer::CommentList* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void DMService_Stub::AddCommentForRestaurant(::google::protobuf::RpcController* controller,
                              const ::ProtocolBuffer::Query* request,
                              ::ProtocolBuffer::Comment* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}

}  // namespace ProtocolBuffer
