// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MapProtocol.proto

#ifndef PROTOBUF_MapProtocol_2eproto__INCLUDED
#define PROTOBUF_MapProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace ProtocolBuffer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MapProtocol_2eproto();
void protobuf_AssignDesc_MapProtocol_2eproto();
void protobuf_ShutdownFile_MapProtocol_2eproto();

class Location;
class LocationEx;
class Route;
class Area;
class AreaEx;
class Time;
class Comment;
class Currency;
class Error;
class User;
class Restaurant;
class RestaurantList;
class CommentList;
class UserList;
class RestaurantType;
class SearchResult;
class Query;
class DMessage;

enum SystemMessageType {
  RequestRouting = 1,
  RejectRouting = 2,
  RoutingReply = 3,
  ShareLocationWith = 4,
  StopShareLocationWith = 5,
  UserLocationUpdate = 6,
  RequestSubscriptionUpdate = 7,
  SubscriptionData = 8,
  SubscribTo = 9,
  UnSubscribeFrom = 10
};
bool SystemMessageType_IsValid(int value);
const SystemMessageType SystemMessageType_MIN = RequestRouting;
const SystemMessageType SystemMessageType_MAX = UnSubscribeFrom;
const int SystemMessageType_ARRAYSIZE = SystemMessageType_MAX + 1;

// ===================================================================

class Location : public ::google::protobuf::MessageLite {
 public:
  Location();
  virtual ~Location();
  
  Location(const Location& from);
  
  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Location& default_instance();
  
  void Swap(Location* other);
  
  // implements Message ----------------------------------------------
  
  Location* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double latitude = 1;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  inline double latitude() const;
  inline void set_latitude(double value);
  
  // required double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.Location)
 private:
  mutable int _cached_size_;
  
  double latitude_;
  double longitude_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// -------------------------------------------------------------------

class LocationEx : public ::google::protobuf::MessageLite {
 public:
  LocationEx();
  virtual ~LocationEx();
  
  LocationEx(const LocationEx& from);
  
  inline LocationEx& operator=(const LocationEx& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const LocationEx& default_instance();
  
  void Swap(LocationEx* other);
  
  // implements Message ----------------------------------------------
  
  LocationEx* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LocationEx& from);
  void MergeFrom(const LocationEx& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .ProtocolBuffer.Location Location_Geo = 1;
  inline bool has_location_geo() const;
  inline void clear_location_geo();
  static const int kLocationGeoFieldNumber = 1;
  inline const ::ProtocolBuffer::Location& location_geo() const;
  inline ::ProtocolBuffer::Location* mutable_location_geo();
  
  // optional string Location_St = 2;
  inline bool has_location_st() const;
  inline void clear_location_st();
  static const int kLocationStFieldNumber = 2;
  inline const ::std::string& location_st() const;
  inline void set_location_st(const ::std::string& value);
  inline void set_location_st(const char* value);
  inline void set_location_st(const char* value, size_t size);
  inline ::std::string* mutable_location_st();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.LocationEx)
 private:
  mutable int _cached_size_;
  
  ::ProtocolBuffer::Location* location_geo_;
  ::std::string* location_st_;
  static const ::std::string _default_location_st_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LocationEx* default_instance_;
};
// -------------------------------------------------------------------

class Route : public ::google::protobuf::MessageLite {
 public:
  Route();
  virtual ~Route();
  
  Route(const Route& from);
  
  inline Route& operator=(const Route& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Route& default_instance();
  
  void Swap(Route* other);
  
  // implements Message ----------------------------------------------
  
  Route* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Route& from);
  void MergeFrom(const Route& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ProtocolBuffer.Location WayPoints = 1;
  inline int waypoints_size() const;
  inline void clear_waypoints();
  static const int kWayPointsFieldNumber = 1;
  inline const ::ProtocolBuffer::Location& waypoints(int index) const;
  inline ::ProtocolBuffer::Location* mutable_waypoints(int index);
  inline ::ProtocolBuffer::Location* add_waypoints();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Location >&
      waypoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Location >*
      mutable_waypoints();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.Route)
 private:
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Location > waypoints_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Route* default_instance_;
};
// -------------------------------------------------------------------

class Area : public ::google::protobuf::MessageLite {
 public:
  Area();
  virtual ~Area();
  
  Area(const Area& from);
  
  inline Area& operator=(const Area& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Area& default_instance();
  
  void Swap(Area* other);
  
  // implements Message ----------------------------------------------
  
  Area* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Area& from);
  void MergeFrom(const Area& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ProtocolBuffer.Location northeast = 1;
  inline bool has_northeast() const;
  inline void clear_northeast();
  static const int kNortheastFieldNumber = 1;
  inline const ::ProtocolBuffer::Location& northeast() const;
  inline ::ProtocolBuffer::Location* mutable_northeast();
  
  // required .ProtocolBuffer.Location southwest = 2;
  inline bool has_southwest() const;
  inline void clear_southwest();
  static const int kSouthwestFieldNumber = 2;
  inline const ::ProtocolBuffer::Location& southwest() const;
  inline ::ProtocolBuffer::Location* mutable_southwest();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.Area)
 private:
  mutable int _cached_size_;
  
  ::ProtocolBuffer::Location* northeast_;
  ::ProtocolBuffer::Location* southwest_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Area* default_instance_;
};
// -------------------------------------------------------------------

class AreaEx : public ::google::protobuf::MessageLite {
 public:
  AreaEx();
  virtual ~AreaEx();
  
  AreaEx(const AreaEx& from);
  
  inline AreaEx& operator=(const AreaEx& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const AreaEx& default_instance();
  
  void Swap(AreaEx* other);
  
  // implements Message ----------------------------------------------
  
  AreaEx* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AreaEx& from);
  void MergeFrom(const AreaEx& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ProtocolBuffer.LocationEx northeast = 1;
  inline bool has_northeast() const;
  inline void clear_northeast();
  static const int kNortheastFieldNumber = 1;
  inline const ::ProtocolBuffer::LocationEx& northeast() const;
  inline ::ProtocolBuffer::LocationEx* mutable_northeast();
  
  // required .ProtocolBuffer.LocationEx southwest = 2;
  inline bool has_southwest() const;
  inline void clear_southwest();
  static const int kSouthwestFieldNumber = 2;
  inline const ::ProtocolBuffer::LocationEx& southwest() const;
  inline ::ProtocolBuffer::LocationEx* mutable_southwest();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.AreaEx)
 private:
  mutable int _cached_size_;
  
  ::ProtocolBuffer::LocationEx* northeast_;
  ::ProtocolBuffer::LocationEx* southwest_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AreaEx* default_instance_;
};
// -------------------------------------------------------------------

class Time : public ::google::protobuf::MessageLite {
 public:
  Time();
  virtual ~Time();
  
  Time(const Time& from);
  
  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Time& default_instance();
  
  void Swap(Time* other);
  
  // implements Message ----------------------------------------------
  
  Time* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string timeStamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 1;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.Time)
 private:
  mutable int _cached_size_;
  
  ::std::string* timestamp_;
  static const ::std::string _default_timestamp_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Time* default_instance_;
};
// -------------------------------------------------------------------

class Comment : public ::google::protobuf::MessageLite {
 public:
  Comment();
  virtual ~Comment();
  
  Comment(const Comment& from);
  
  inline Comment& operator=(const Comment& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Comment& default_instance();
  
  void Swap(Comment* other);
  
  // implements Message ----------------------------------------------
  
  Comment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Comment& from);
  void MergeFrom(const Comment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  
  // required .ProtocolBuffer.Time timeStamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 2;
  inline const ::ProtocolBuffer::Time& timestamp() const;
  inline ::ProtocolBuffer::Time* mutable_timestamp();
  
  // required uint32 UID = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUIDFieldNumber = 3;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);
  
  // required uint32 RID = 4;
  inline bool has_rid() const;
  inline void clear_rid();
  static const int kRIDFieldNumber = 4;
  inline ::google::protobuf::uint32 rid() const;
  inline void set_rid(::google::protobuf::uint32 value);
  
  // optional .ProtocolBuffer.Restaurant RestaurantInfo = 7;
  inline bool has_restaurantinfo() const;
  inline void clear_restaurantinfo();
  static const int kRestaurantInfoFieldNumber = 7;
  inline const ::ProtocolBuffer::Restaurant& restaurantinfo() const;
  inline ::ProtocolBuffer::Restaurant* mutable_restaurantinfo();
  
  // optional .ProtocolBuffer.User UserInfo = 6;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 6;
  inline const ::ProtocolBuffer::User& userinfo() const;
  inline ::ProtocolBuffer::User* mutable_userinfo();
  
  // optional uint32 DID = 5;
  inline bool has_did() const;
  inline void clear_did();
  static const int kDIDFieldNumber = 5;
  inline ::google::protobuf::uint32 did() const;
  inline void set_did(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.Comment)
 private:
  mutable int _cached_size_;
  
  ::std::string* content_;
  static const ::std::string _default_content_;
  ::ProtocolBuffer::Time* timestamp_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 rid_;
  ::ProtocolBuffer::Restaurant* restaurantinfo_;
  ::ProtocolBuffer::User* userinfo_;
  ::google::protobuf::uint32 did_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Comment* default_instance_;
};
// -------------------------------------------------------------------

class Currency : public ::google::protobuf::MessageLite {
 public:
  Currency();
  virtual ~Currency();
  
  Currency(const Currency& from);
  
  inline Currency& operator=(const Currency& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Currency& default_instance();
  
  void Swap(Currency* other);
  
  // implements Message ----------------------------------------------
  
  Currency* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Currency& from);
  void MergeFrom(const Currency& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float amount = 1;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline float amount() const;
  inline void set_amount(float value);
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.Currency)
 private:
  mutable int _cached_size_;
  
  float amount_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Currency* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::MessageLite {
 public:
  Error();
  virtual ~Error();
  
  Error(const Error& from);
  
  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Error& default_instance();
  
  void Swap(Error* other);
  
  // implements Message ----------------------------------------------
  
  Error* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.Error)
 private:
  mutable int _cached_size_;
  
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::MessageLite {
 public:
  User();
  virtual ~User();
  
  User(const User& from);
  
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const User& default_instance();
  
  void Swap(User* other);
  
  // implements Message ----------------------------------------------
  
  User* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 UID = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUIDFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);
  
  // required string emailAddress = 2;
  inline bool has_emailaddress() const;
  inline void clear_emailaddress();
  static const int kEmailAddressFieldNumber = 2;
  inline const ::std::string& emailaddress() const;
  inline void set_emailaddress(const ::std::string& value);
  inline void set_emailaddress(const char* value);
  inline void set_emailaddress(const char* value, size_t size);
  inline ::std::string* mutable_emailaddress();
  
  // required string nickName = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  
  // required string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  
  // required .ProtocolBuffer.Time joinTime = 5;
  inline bool has_jointime() const;
  inline void clear_jointime();
  static const int kJoinTimeFieldNumber = 5;
  inline const ::ProtocolBuffer::Time& jointime() const;
  inline ::ProtocolBuffer::Time* mutable_jointime();
  
  // optional .ProtocolBuffer.Location lastLocation = 6;
  inline bool has_lastlocation() const;
  inline void clear_lastlocation();
  static const int kLastLocationFieldNumber = 6;
  inline const ::ProtocolBuffer::Location& lastlocation() const;
  inline ::ProtocolBuffer::Location* mutable_lastlocation();
  
  // repeated .ProtocolBuffer.RestaurantType preferTypes = 7;
  inline int prefertypes_size() const;
  inline void clear_prefertypes();
  static const int kPreferTypesFieldNumber = 7;
  inline const ::ProtocolBuffer::RestaurantType& prefertypes(int index) const;
  inline ::ProtocolBuffer::RestaurantType* mutable_prefertypes(int index);
  inline ::ProtocolBuffer::RestaurantType* add_prefertypes();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::RestaurantType >&
      prefertypes() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::RestaurantType >*
      mutable_prefertypes();
  
  // repeated uint32 friends = 8;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 8;
  inline ::google::protobuf::uint32 friends(int index) const;
  inline void set_friends(int index, ::google::protobuf::uint32 value);
  inline void add_friends(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      friends() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_friends();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.User)
 private:
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 uid_;
  ::std::string* emailaddress_;
  static const ::std::string _default_emailaddress_;
  ::std::string* nickname_;
  static const ::std::string _default_nickname_;
  ::std::string* password_;
  static const ::std::string _default_password_;
  ::ProtocolBuffer::Time* jointime_;
  ::ProtocolBuffer::Location* lastlocation_;
  ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::RestaurantType > prefertypes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > friends_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class Restaurant : public ::google::protobuf::MessageLite {
 public:
  Restaurant();
  virtual ~Restaurant();
  
  Restaurant(const Restaurant& from);
  
  inline Restaurant& operator=(const Restaurant& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Restaurant& default_instance();
  
  void Swap(Restaurant* other);
  
  // implements Message ----------------------------------------------
  
  Restaurant* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Restaurant& from);
  void MergeFrom(const Restaurant& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ProtocolBuffer.Location location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::ProtocolBuffer::Location& location() const;
  inline ::ProtocolBuffer::Location* mutable_location();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required uint32 RID = 3;
  inline bool has_rid() const;
  inline void clear_rid();
  static const int kRIDFieldNumber = 3;
  inline ::google::protobuf::uint32 rid() const;
  inline void set_rid(::google::protobuf::uint32 value);
  
  // required .ProtocolBuffer.RestaurantType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline const ::ProtocolBuffer::RestaurantType& type() const;
  inline ::ProtocolBuffer::RestaurantType* mutable_type();
  
  // required uint32 Rating = 5;
  inline bool has_rating() const;
  inline void clear_rating();
  static const int kRatingFieldNumber = 5;
  inline ::google::protobuf::uint32 rating() const;
  inline void set_rating(::google::protobuf::uint32 value);
  
  // required uint32 CommentCount = 6;
  inline bool has_commentcount() const;
  inline void clear_commentcount();
  static const int kCommentCountFieldNumber = 6;
  inline ::google::protobuf::uint32 commentcount() const;
  inline void set_commentcount(::google::protobuf::uint32 value);
  
  // required .ProtocolBuffer.Currency averageExpense = 7;
  inline bool has_averageexpense() const;
  inline void clear_averageexpense();
  static const int kAverageExpenseFieldNumber = 7;
  inline const ::ProtocolBuffer::Currency& averageexpense() const;
  inline ::ProtocolBuffer::Currency* mutable_averageexpense();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.Restaurant)
 private:
  mutable int _cached_size_;
  
  ::ProtocolBuffer::Location* location_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::uint32 rid_;
  ::ProtocolBuffer::RestaurantType* type_;
  ::google::protobuf::uint32 rating_;
  ::google::protobuf::uint32 commentcount_;
  ::ProtocolBuffer::Currency* averageexpense_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Restaurant* default_instance_;
};
// -------------------------------------------------------------------

class RestaurantList : public ::google::protobuf::MessageLite {
 public:
  RestaurantList();
  virtual ~RestaurantList();
  
  RestaurantList(const RestaurantList& from);
  
  inline RestaurantList& operator=(const RestaurantList& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RestaurantList& default_instance();
  
  void Swap(RestaurantList* other);
  
  // implements Message ----------------------------------------------
  
  RestaurantList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RestaurantList& from);
  void MergeFrom(const RestaurantList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ProtocolBuffer.Restaurant restaurants = 1;
  inline int restaurants_size() const;
  inline void clear_restaurants();
  static const int kRestaurantsFieldNumber = 1;
  inline const ::ProtocolBuffer::Restaurant& restaurants(int index) const;
  inline ::ProtocolBuffer::Restaurant* mutable_restaurants(int index);
  inline ::ProtocolBuffer::Restaurant* add_restaurants();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Restaurant >&
      restaurants() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Restaurant >*
      mutable_restaurants();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.RestaurantList)
 private:
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Restaurant > restaurants_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RestaurantList* default_instance_;
};
// -------------------------------------------------------------------

class CommentList : public ::google::protobuf::MessageLite {
 public:
  CommentList();
  virtual ~CommentList();
  
  CommentList(const CommentList& from);
  
  inline CommentList& operator=(const CommentList& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const CommentList& default_instance();
  
  void Swap(CommentList* other);
  
  // implements Message ----------------------------------------------
  
  CommentList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommentList& from);
  void MergeFrom(const CommentList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ProtocolBuffer.Comment comments = 1;
  inline int comments_size() const;
  inline void clear_comments();
  static const int kCommentsFieldNumber = 1;
  inline const ::ProtocolBuffer::Comment& comments(int index) const;
  inline ::ProtocolBuffer::Comment* mutable_comments(int index);
  inline ::ProtocolBuffer::Comment* add_comments();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Comment >&
      comments() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Comment >*
      mutable_comments();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.CommentList)
 private:
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Comment > comments_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CommentList* default_instance_;
};
// -------------------------------------------------------------------

class UserList : public ::google::protobuf::MessageLite {
 public:
  UserList();
  virtual ~UserList();
  
  UserList(const UserList& from);
  
  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UserList& default_instance();
  
  void Swap(UserList* other);
  
  // implements Message ----------------------------------------------
  
  UserList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ProtocolBuffer.User users = 1;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 1;
  inline const ::ProtocolBuffer::User& users(int index) const;
  inline ::ProtocolBuffer::User* mutable_users(int index);
  inline ::ProtocolBuffer::User* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::User >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::User >*
      mutable_users();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.UserList)
 private:
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::User > users_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UserList* default_instance_;
};
// -------------------------------------------------------------------

class RestaurantType : public ::google::protobuf::MessageLite {
 public:
  RestaurantType();
  virtual ~RestaurantType();
  
  RestaurantType(const RestaurantType& from);
  
  inline RestaurantType& operator=(const RestaurantType& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const RestaurantType& default_instance();
  
  void Swap(RestaurantType* other);
  
  // implements Message ----------------------------------------------
  
  RestaurantType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RestaurantType& from);
  void MergeFrom(const RestaurantType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 TID = 1;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTIDFieldNumber = 1;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.RestaurantType)
 private:
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 tid_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RestaurantType* default_instance_;
};
// -------------------------------------------------------------------

class SearchResult : public ::google::protobuf::MessageLite {
 public:
  SearchResult();
  virtual ~SearchResult();
  
  SearchResult(const SearchResult& from);
  
  inline SearchResult& operator=(const SearchResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const SearchResult& default_instance();
  
  void Swap(SearchResult* other);
  
  // implements Message ----------------------------------------------
  
  SearchResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SearchResult& from);
  void MergeFrom(const SearchResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .ProtocolBuffer.RestaurantList restaurants = 1;
  inline bool has_restaurants() const;
  inline void clear_restaurants();
  static const int kRestaurantsFieldNumber = 1;
  inline const ::ProtocolBuffer::RestaurantList& restaurants() const;
  inline ::ProtocolBuffer::RestaurantList* mutable_restaurants();
  
  // optional .ProtocolBuffer.UserList users = 2;
  inline bool has_users() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 2;
  inline const ::ProtocolBuffer::UserList& users() const;
  inline ::ProtocolBuffer::UserList* mutable_users();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.SearchResult)
 private:
  mutable int _cached_size_;
  
  ::ProtocolBuffer::RestaurantList* restaurants_;
  ::ProtocolBuffer::UserList* users_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SearchResult* default_instance_;
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::MessageLite {
 public:
  Query();
  virtual ~Query();
  
  Query(const Query& from);
  
  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Query& default_instance();
  
  void Swap(Query* other);
  
  // implements Message ----------------------------------------------
  
  Query* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .ProtocolBuffer.Area area = 1;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 1;
  inline const ::ProtocolBuffer::Area& area() const;
  inline ::ProtocolBuffer::Area* mutable_area();
  
  // optional uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);
  
  // optional .ProtocolBuffer.Time time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline const ::ProtocolBuffer::Time& time() const;
  inline ::ProtocolBuffer::Time* mutable_time();
  
  // optional uint32 RID = 4;
  inline bool has_rid() const;
  inline void clear_rid();
  static const int kRIDFieldNumber = 4;
  inline ::google::protobuf::uint32 rid() const;
  inline void set_rid(::google::protobuf::uint32 value);
  
  // optional uint32 UID = 5;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUIDFieldNumber = 5;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);
  
  // optional uint32 n = 6;
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 6;
  inline ::google::protobuf::uint32 n() const;
  inline void set_n(::google::protobuf::uint32 value);
  
  // optional uint32 UID_Target = 13;
  inline bool has_uid_target() const;
  inline void clear_uid_target();
  static const int kUIDTargetFieldNumber = 13;
  inline ::google::protobuf::uint32 uid_target() const;
  inline void set_uid_target(::google::protobuf::uint32 value);
  
  // optional uint32 relation = 12;
  inline bool has_relation() const;
  inline void clear_relation();
  static const int kRelationFieldNumber = 12;
  inline ::google::protobuf::uint32 relation() const;
  inline void set_relation(::google::protobuf::uint32 value);
  
  // optional string msg = 7;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 7;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  
  // optional bytes image = 8;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 8;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const void* value, size_t size);
  inline ::std::string* mutable_image();
  
  // optional string emailAddress = 9;
  inline bool has_emailaddress() const;
  inline void clear_emailaddress();
  static const int kEmailAddressFieldNumber = 9;
  inline const ::std::string& emailaddress() const;
  inline void set_emailaddress(const ::std::string& value);
  inline void set_emailaddress(const char* value);
  inline void set_emailaddress(const char* value, size_t size);
  inline ::std::string* mutable_emailaddress();
  
  // optional string password = 10;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 10;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  
  // optional .ProtocolBuffer.User userinfo = 11;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 11;
  inline const ::ProtocolBuffer::User& userinfo() const;
  inline ::ProtocolBuffer::User* mutable_userinfo();
  
  // optional .ProtocolBuffer.Location location = 14;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 14;
  inline const ::ProtocolBuffer::Location& location() const;
  inline ::ProtocolBuffer::Location* mutable_location();
  
  // optional string name = 15;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 15;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.Query)
 private:
  mutable int _cached_size_;
  
  ::ProtocolBuffer::Area* area_;
  ::google::protobuf::uint32 level_;
  ::ProtocolBuffer::Time* time_;
  ::google::protobuf::uint32 rid_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 n_;
  ::google::protobuf::uint32 uid_target_;
  ::google::protobuf::uint32 relation_;
  ::std::string* msg_;
  static const ::std::string _default_msg_;
  ::std::string* image_;
  static const ::std::string _default_image_;
  ::std::string* emailaddress_;
  static const ::std::string _default_emailaddress_;
  ::std::string* password_;
  static const ::std::string _default_password_;
  ::ProtocolBuffer::User* userinfo_;
  ::ProtocolBuffer::Location* location_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Query* default_instance_;
};
// -------------------------------------------------------------------

class DMessage : public ::google::protobuf::MessageLite {
 public:
  DMessage();
  virtual ~DMessage();
  
  DMessage(const DMessage& from);
  
  inline DMessage& operator=(const DMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const DMessage& default_instance();
  
  void Swap(DMessage* other);
  
  // implements Message ----------------------------------------------
  
  DMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DMessage& from);
  void MergeFrom(const DMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 fromUser = 1;
  inline bool has_fromuser() const;
  inline void clear_fromuser();
  static const int kFromUserFieldNumber = 1;
  inline ::google::protobuf::uint32 fromuser() const;
  inline void set_fromuser(::google::protobuf::uint32 value);
  
  // required uint32 toUser = 2;
  inline bool has_touser() const;
  inline void clear_touser();
  static const int kToUserFieldNumber = 2;
  inline ::google::protobuf::uint32 touser() const;
  inline void set_touser(::google::protobuf::uint32 value);
  
  // required uint32 msgID = 6;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIDFieldNumber = 6;
  inline ::google::protobuf::uint32 msgid() const;
  inline void set_msgid(::google::protobuf::uint32 value);
  
  // required bool isSystemMessage = 7;
  inline bool has_issystemmessage() const;
  inline void clear_issystemmessage();
  static const int kIsSystemMessageFieldNumber = 7;
  inline bool issystemmessage() const;
  inline void set_issystemmessage(bool value);
  
  // optional string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  
  // optional .ProtocolBuffer.SystemMessageType systemMessageType = 4;
  inline bool has_systemmessagetype() const;
  inline void clear_systemmessagetype();
  static const int kSystemMessageTypeFieldNumber = 4;
  inline ProtocolBuffer::SystemMessageType systemmessagetype() const;
  inline void set_systemmessagetype(ProtocolBuffer::SystemMessageType value);
  
  // optional string buffer = 5;
  inline bool has_buffer() const;
  inline void clear_buffer();
  static const int kBufferFieldNumber = 5;
  inline const ::std::string& buffer() const;
  inline void set_buffer(const ::std::string& value);
  inline void set_buffer(const char* value);
  inline void set_buffer(const char* value, size_t size);
  inline ::std::string* mutable_buffer();
  
  // @@protoc_insertion_point(class_scope:ProtocolBuffer.DMessage)
 private:
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 fromuser_;
  ::google::protobuf::uint32 touser_;
  ::google::protobuf::uint32 msgid_;
  bool issystemmessage_;
  ::std::string* text_;
  static const ::std::string _default_text_;
  int systemmessagetype_;
  ::std::string* buffer_;
  static const ::std::string _default_buffer_;
  friend void  protobuf_AddDesc_MapProtocol_2eproto();
  friend void protobuf_AssignDesc_MapProtocol_2eproto();
  friend void protobuf_ShutdownFile_MapProtocol_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// Location

// required double latitude = 1;
inline bool Location::has_latitude() const {
  return _has_bit(0);
}
inline void Location::clear_latitude() {
  latitude_ = 0;
  _clear_bit(0);
}
inline double Location::latitude() const {
  return latitude_;
}
inline void Location::set_latitude(double value) {
  _set_bit(0);
  latitude_ = value;
}

// required double longitude = 2;
inline bool Location::has_longitude() const {
  return _has_bit(1);
}
inline void Location::clear_longitude() {
  longitude_ = 0;
  _clear_bit(1);
}
inline double Location::longitude() const {
  return longitude_;
}
inline void Location::set_longitude(double value) {
  _set_bit(1);
  longitude_ = value;
}

// -------------------------------------------------------------------

// LocationEx

// optional .ProtocolBuffer.Location Location_Geo = 1;
inline bool LocationEx::has_location_geo() const {
  return _has_bit(0);
}
inline void LocationEx::clear_location_geo() {
  if (location_geo_ != NULL) location_geo_->::ProtocolBuffer::Location::Clear();
  _clear_bit(0);
}
inline const ::ProtocolBuffer::Location& LocationEx::location_geo() const {
  return location_geo_ != NULL ? *location_geo_ : *default_instance_->location_geo_;
}
inline ::ProtocolBuffer::Location* LocationEx::mutable_location_geo() {
  _set_bit(0);
  if (location_geo_ == NULL) location_geo_ = new ::ProtocolBuffer::Location;
  return location_geo_;
}

// optional string Location_St = 2;
inline bool LocationEx::has_location_st() const {
  return _has_bit(1);
}
inline void LocationEx::clear_location_st() {
  if (location_st_ != &_default_location_st_) {
    location_st_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LocationEx::location_st() const {
  return *location_st_;
}
inline void LocationEx::set_location_st(const ::std::string& value) {
  _set_bit(1);
  if (location_st_ == &_default_location_st_) {
    location_st_ = new ::std::string;
  }
  location_st_->assign(value);
}
inline void LocationEx::set_location_st(const char* value) {
  _set_bit(1);
  if (location_st_ == &_default_location_st_) {
    location_st_ = new ::std::string;
  }
  location_st_->assign(value);
}
inline void LocationEx::set_location_st(const char* value, size_t size) {
  _set_bit(1);
  if (location_st_ == &_default_location_st_) {
    location_st_ = new ::std::string;
  }
  location_st_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocationEx::mutable_location_st() {
  _set_bit(1);
  if (location_st_ == &_default_location_st_) {
    location_st_ = new ::std::string;
  }
  return location_st_;
}

// -------------------------------------------------------------------

// Route

// repeated .ProtocolBuffer.Location WayPoints = 1;
inline int Route::waypoints_size() const {
  return waypoints_.size();
}
inline void Route::clear_waypoints() {
  waypoints_.Clear();
}
inline const ::ProtocolBuffer::Location& Route::waypoints(int index) const {
  return waypoints_.Get(index);
}
inline ::ProtocolBuffer::Location* Route::mutable_waypoints(int index) {
  return waypoints_.Mutable(index);
}
inline ::ProtocolBuffer::Location* Route::add_waypoints() {
  return waypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Location >&
Route::waypoints() const {
  return waypoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Location >*
Route::mutable_waypoints() {
  return &waypoints_;
}

// -------------------------------------------------------------------

// Area

// required .ProtocolBuffer.Location northeast = 1;
inline bool Area::has_northeast() const {
  return _has_bit(0);
}
inline void Area::clear_northeast() {
  if (northeast_ != NULL) northeast_->::ProtocolBuffer::Location::Clear();
  _clear_bit(0);
}
inline const ::ProtocolBuffer::Location& Area::northeast() const {
  return northeast_ != NULL ? *northeast_ : *default_instance_->northeast_;
}
inline ::ProtocolBuffer::Location* Area::mutable_northeast() {
  _set_bit(0);
  if (northeast_ == NULL) northeast_ = new ::ProtocolBuffer::Location;
  return northeast_;
}

// required .ProtocolBuffer.Location southwest = 2;
inline bool Area::has_southwest() const {
  return _has_bit(1);
}
inline void Area::clear_southwest() {
  if (southwest_ != NULL) southwest_->::ProtocolBuffer::Location::Clear();
  _clear_bit(1);
}
inline const ::ProtocolBuffer::Location& Area::southwest() const {
  return southwest_ != NULL ? *southwest_ : *default_instance_->southwest_;
}
inline ::ProtocolBuffer::Location* Area::mutable_southwest() {
  _set_bit(1);
  if (southwest_ == NULL) southwest_ = new ::ProtocolBuffer::Location;
  return southwest_;
}

// -------------------------------------------------------------------

// AreaEx

// required .ProtocolBuffer.LocationEx northeast = 1;
inline bool AreaEx::has_northeast() const {
  return _has_bit(0);
}
inline void AreaEx::clear_northeast() {
  if (northeast_ != NULL) northeast_->::ProtocolBuffer::LocationEx::Clear();
  _clear_bit(0);
}
inline const ::ProtocolBuffer::LocationEx& AreaEx::northeast() const {
  return northeast_ != NULL ? *northeast_ : *default_instance_->northeast_;
}
inline ::ProtocolBuffer::LocationEx* AreaEx::mutable_northeast() {
  _set_bit(0);
  if (northeast_ == NULL) northeast_ = new ::ProtocolBuffer::LocationEx;
  return northeast_;
}

// required .ProtocolBuffer.LocationEx southwest = 2;
inline bool AreaEx::has_southwest() const {
  return _has_bit(1);
}
inline void AreaEx::clear_southwest() {
  if (southwest_ != NULL) southwest_->::ProtocolBuffer::LocationEx::Clear();
  _clear_bit(1);
}
inline const ::ProtocolBuffer::LocationEx& AreaEx::southwest() const {
  return southwest_ != NULL ? *southwest_ : *default_instance_->southwest_;
}
inline ::ProtocolBuffer::LocationEx* AreaEx::mutable_southwest() {
  _set_bit(1);
  if (southwest_ == NULL) southwest_ = new ::ProtocolBuffer::LocationEx;
  return southwest_;
}

// -------------------------------------------------------------------

// Time

// required string timeStamp = 1;
inline bool Time::has_timestamp() const {
  return _has_bit(0);
}
inline void Time::clear_timestamp() {
  if (timestamp_ != &_default_timestamp_) {
    timestamp_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Time::timestamp() const {
  return *timestamp_;
}
inline void Time::set_timestamp(const ::std::string& value) {
  _set_bit(0);
  if (timestamp_ == &_default_timestamp_) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void Time::set_timestamp(const char* value) {
  _set_bit(0);
  if (timestamp_ == &_default_timestamp_) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void Time::set_timestamp(const char* value, size_t size) {
  _set_bit(0);
  if (timestamp_ == &_default_timestamp_) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Time::mutable_timestamp() {
  _set_bit(0);
  if (timestamp_ == &_default_timestamp_) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}

// -------------------------------------------------------------------

// Comment

// required string content = 1;
inline bool Comment::has_content() const {
  return _has_bit(0);
}
inline void Comment::clear_content() {
  if (content_ != &_default_content_) {
    content_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Comment::content() const {
  return *content_;
}
inline void Comment::set_content(const ::std::string& value) {
  _set_bit(0);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Comment::set_content(const char* value) {
  _set_bit(0);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Comment::set_content(const char* value, size_t size) {
  _set_bit(0);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Comment::mutable_content() {
  _set_bit(0);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  return content_;
}

// required .ProtocolBuffer.Time timeStamp = 2;
inline bool Comment::has_timestamp() const {
  return _has_bit(1);
}
inline void Comment::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::ProtocolBuffer::Time::Clear();
  _clear_bit(1);
}
inline const ::ProtocolBuffer::Time& Comment::timestamp() const {
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::ProtocolBuffer::Time* Comment::mutable_timestamp() {
  _set_bit(1);
  if (timestamp_ == NULL) timestamp_ = new ::ProtocolBuffer::Time;
  return timestamp_;
}

// required uint32 UID = 3;
inline bool Comment::has_uid() const {
  return _has_bit(2);
}
inline void Comment::clear_uid() {
  uid_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 Comment::uid() const {
  return uid_;
}
inline void Comment::set_uid(::google::protobuf::uint32 value) {
  _set_bit(2);
  uid_ = value;
}

// required uint32 RID = 4;
inline bool Comment::has_rid() const {
  return _has_bit(3);
}
inline void Comment::clear_rid() {
  rid_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 Comment::rid() const {
  return rid_;
}
inline void Comment::set_rid(::google::protobuf::uint32 value) {
  _set_bit(3);
  rid_ = value;
}

// optional .ProtocolBuffer.Restaurant RestaurantInfo = 7;
inline bool Comment::has_restaurantinfo() const {
  return _has_bit(4);
}
inline void Comment::clear_restaurantinfo() {
  if (restaurantinfo_ != NULL) restaurantinfo_->::ProtocolBuffer::Restaurant::Clear();
  _clear_bit(4);
}
inline const ::ProtocolBuffer::Restaurant& Comment::restaurantinfo() const {
  return restaurantinfo_ != NULL ? *restaurantinfo_ : *default_instance_->restaurantinfo_;
}
inline ::ProtocolBuffer::Restaurant* Comment::mutable_restaurantinfo() {
  _set_bit(4);
  if (restaurantinfo_ == NULL) restaurantinfo_ = new ::ProtocolBuffer::Restaurant;
  return restaurantinfo_;
}

// optional .ProtocolBuffer.User UserInfo = 6;
inline bool Comment::has_userinfo() const {
  return _has_bit(5);
}
inline void Comment::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::ProtocolBuffer::User::Clear();
  _clear_bit(5);
}
inline const ::ProtocolBuffer::User& Comment::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::ProtocolBuffer::User* Comment::mutable_userinfo() {
  _set_bit(5);
  if (userinfo_ == NULL) userinfo_ = new ::ProtocolBuffer::User;
  return userinfo_;
}

// optional uint32 DID = 5;
inline bool Comment::has_did() const {
  return _has_bit(6);
}
inline void Comment::clear_did() {
  did_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 Comment::did() const {
  return did_;
}
inline void Comment::set_did(::google::protobuf::uint32 value) {
  _set_bit(6);
  did_ = value;
}

// -------------------------------------------------------------------

// Currency

// required float amount = 1;
inline bool Currency::has_amount() const {
  return _has_bit(0);
}
inline void Currency::clear_amount() {
  amount_ = 0;
  _clear_bit(0);
}
inline float Currency::amount() const {
  return amount_;
}
inline void Currency::set_amount(float value) {
  _set_bit(0);
  amount_ = value;
}

// -------------------------------------------------------------------

// Error

// required string message = 1;
inline bool Error::has_message() const {
  return _has_bit(0);
}
inline void Error::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Error::message() const {
  return *message_;
}
inline void Error::set_message(const ::std::string& value) {
  _set_bit(0);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Error::set_message(const char* value) {
  _set_bit(0);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Error::set_message(const char* value, size_t size) {
  _set_bit(0);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Error::mutable_message() {
  _set_bit(0);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// User

// required uint32 UID = 1;
inline bool User::has_uid() const {
  return _has_bit(0);
}
inline void User::clear_uid() {
  uid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 User::uid() const {
  return uid_;
}
inline void User::set_uid(::google::protobuf::uint32 value) {
  _set_bit(0);
  uid_ = value;
}

// required string emailAddress = 2;
inline bool User::has_emailaddress() const {
  return _has_bit(1);
}
inline void User::clear_emailaddress() {
  if (emailaddress_ != &_default_emailaddress_) {
    emailaddress_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& User::emailaddress() const {
  return *emailaddress_;
}
inline void User::set_emailaddress(const ::std::string& value) {
  _set_bit(1);
  if (emailaddress_ == &_default_emailaddress_) {
    emailaddress_ = new ::std::string;
  }
  emailaddress_->assign(value);
}
inline void User::set_emailaddress(const char* value) {
  _set_bit(1);
  if (emailaddress_ == &_default_emailaddress_) {
    emailaddress_ = new ::std::string;
  }
  emailaddress_->assign(value);
}
inline void User::set_emailaddress(const char* value, size_t size) {
  _set_bit(1);
  if (emailaddress_ == &_default_emailaddress_) {
    emailaddress_ = new ::std::string;
  }
  emailaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_emailaddress() {
  _set_bit(1);
  if (emailaddress_ == &_default_emailaddress_) {
    emailaddress_ = new ::std::string;
  }
  return emailaddress_;
}

// required string nickName = 3;
inline bool User::has_nickname() const {
  return _has_bit(2);
}
inline void User::clear_nickname() {
  if (nickname_ != &_default_nickname_) {
    nickname_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& User::nickname() const {
  return *nickname_;
}
inline void User::set_nickname(const ::std::string& value) {
  _set_bit(2);
  if (nickname_ == &_default_nickname_) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void User::set_nickname(const char* value) {
  _set_bit(2);
  if (nickname_ == &_default_nickname_) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void User::set_nickname(const char* value, size_t size) {
  _set_bit(2);
  if (nickname_ == &_default_nickname_) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_nickname() {
  _set_bit(2);
  if (nickname_ == &_default_nickname_) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}

// required string password = 4;
inline bool User::has_password() const {
  return _has_bit(3);
}
inline void User::clear_password() {
  if (password_ != &_default_password_) {
    password_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& User::password() const {
  return *password_;
}
inline void User::set_password(const ::std::string& value) {
  _set_bit(3);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void User::set_password(const char* value) {
  _set_bit(3);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void User::set_password(const char* value, size_t size) {
  _set_bit(3);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_password() {
  _set_bit(3);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  return password_;
}

// required .ProtocolBuffer.Time joinTime = 5;
inline bool User::has_jointime() const {
  return _has_bit(4);
}
inline void User::clear_jointime() {
  if (jointime_ != NULL) jointime_->::ProtocolBuffer::Time::Clear();
  _clear_bit(4);
}
inline const ::ProtocolBuffer::Time& User::jointime() const {
  return jointime_ != NULL ? *jointime_ : *default_instance_->jointime_;
}
inline ::ProtocolBuffer::Time* User::mutable_jointime() {
  _set_bit(4);
  if (jointime_ == NULL) jointime_ = new ::ProtocolBuffer::Time;
  return jointime_;
}

// optional .ProtocolBuffer.Location lastLocation = 6;
inline bool User::has_lastlocation() const {
  return _has_bit(5);
}
inline void User::clear_lastlocation() {
  if (lastlocation_ != NULL) lastlocation_->::ProtocolBuffer::Location::Clear();
  _clear_bit(5);
}
inline const ::ProtocolBuffer::Location& User::lastlocation() const {
  return lastlocation_ != NULL ? *lastlocation_ : *default_instance_->lastlocation_;
}
inline ::ProtocolBuffer::Location* User::mutable_lastlocation() {
  _set_bit(5);
  if (lastlocation_ == NULL) lastlocation_ = new ::ProtocolBuffer::Location;
  return lastlocation_;
}

// repeated .ProtocolBuffer.RestaurantType preferTypes = 7;
inline int User::prefertypes_size() const {
  return prefertypes_.size();
}
inline void User::clear_prefertypes() {
  prefertypes_.Clear();
}
inline const ::ProtocolBuffer::RestaurantType& User::prefertypes(int index) const {
  return prefertypes_.Get(index);
}
inline ::ProtocolBuffer::RestaurantType* User::mutable_prefertypes(int index) {
  return prefertypes_.Mutable(index);
}
inline ::ProtocolBuffer::RestaurantType* User::add_prefertypes() {
  return prefertypes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::RestaurantType >&
User::prefertypes() const {
  return prefertypes_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::RestaurantType >*
User::mutable_prefertypes() {
  return &prefertypes_;
}

// repeated uint32 friends = 8;
inline int User::friends_size() const {
  return friends_.size();
}
inline void User::clear_friends() {
  friends_.Clear();
}
inline ::google::protobuf::uint32 User::friends(int index) const {
  return friends_.Get(index);
}
inline void User::set_friends(int index, ::google::protobuf::uint32 value) {
  friends_.Set(index, value);
}
inline void User::add_friends(::google::protobuf::uint32 value) {
  friends_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
User::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
User::mutable_friends() {
  return &friends_;
}

// -------------------------------------------------------------------

// Restaurant

// required .ProtocolBuffer.Location location = 1;
inline bool Restaurant::has_location() const {
  return _has_bit(0);
}
inline void Restaurant::clear_location() {
  if (location_ != NULL) location_->::ProtocolBuffer::Location::Clear();
  _clear_bit(0);
}
inline const ::ProtocolBuffer::Location& Restaurant::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::ProtocolBuffer::Location* Restaurant::mutable_location() {
  _set_bit(0);
  if (location_ == NULL) location_ = new ::ProtocolBuffer::Location;
  return location_;
}

// required string name = 2;
inline bool Restaurant::has_name() const {
  return _has_bit(1);
}
inline void Restaurant::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Restaurant::name() const {
  return *name_;
}
inline void Restaurant::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Restaurant::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Restaurant::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Restaurant::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required uint32 RID = 3;
inline bool Restaurant::has_rid() const {
  return _has_bit(2);
}
inline void Restaurant::clear_rid() {
  rid_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 Restaurant::rid() const {
  return rid_;
}
inline void Restaurant::set_rid(::google::protobuf::uint32 value) {
  _set_bit(2);
  rid_ = value;
}

// required .ProtocolBuffer.RestaurantType type = 4;
inline bool Restaurant::has_type() const {
  return _has_bit(3);
}
inline void Restaurant::clear_type() {
  if (type_ != NULL) type_->::ProtocolBuffer::RestaurantType::Clear();
  _clear_bit(3);
}
inline const ::ProtocolBuffer::RestaurantType& Restaurant::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::ProtocolBuffer::RestaurantType* Restaurant::mutable_type() {
  _set_bit(3);
  if (type_ == NULL) type_ = new ::ProtocolBuffer::RestaurantType;
  return type_;
}

// required uint32 Rating = 5;
inline bool Restaurant::has_rating() const {
  return _has_bit(4);
}
inline void Restaurant::clear_rating() {
  rating_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 Restaurant::rating() const {
  return rating_;
}
inline void Restaurant::set_rating(::google::protobuf::uint32 value) {
  _set_bit(4);
  rating_ = value;
}

// required uint32 CommentCount = 6;
inline bool Restaurant::has_commentcount() const {
  return _has_bit(5);
}
inline void Restaurant::clear_commentcount() {
  commentcount_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 Restaurant::commentcount() const {
  return commentcount_;
}
inline void Restaurant::set_commentcount(::google::protobuf::uint32 value) {
  _set_bit(5);
  commentcount_ = value;
}

// required .ProtocolBuffer.Currency averageExpense = 7;
inline bool Restaurant::has_averageexpense() const {
  return _has_bit(6);
}
inline void Restaurant::clear_averageexpense() {
  if (averageexpense_ != NULL) averageexpense_->::ProtocolBuffer::Currency::Clear();
  _clear_bit(6);
}
inline const ::ProtocolBuffer::Currency& Restaurant::averageexpense() const {
  return averageexpense_ != NULL ? *averageexpense_ : *default_instance_->averageexpense_;
}
inline ::ProtocolBuffer::Currency* Restaurant::mutable_averageexpense() {
  _set_bit(6);
  if (averageexpense_ == NULL) averageexpense_ = new ::ProtocolBuffer::Currency;
  return averageexpense_;
}

// -------------------------------------------------------------------

// RestaurantList

// repeated .ProtocolBuffer.Restaurant restaurants = 1;
inline int RestaurantList::restaurants_size() const {
  return restaurants_.size();
}
inline void RestaurantList::clear_restaurants() {
  restaurants_.Clear();
}
inline const ::ProtocolBuffer::Restaurant& RestaurantList::restaurants(int index) const {
  return restaurants_.Get(index);
}
inline ::ProtocolBuffer::Restaurant* RestaurantList::mutable_restaurants(int index) {
  return restaurants_.Mutable(index);
}
inline ::ProtocolBuffer::Restaurant* RestaurantList::add_restaurants() {
  return restaurants_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Restaurant >&
RestaurantList::restaurants() const {
  return restaurants_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Restaurant >*
RestaurantList::mutable_restaurants() {
  return &restaurants_;
}

// -------------------------------------------------------------------

// CommentList

// repeated .ProtocolBuffer.Comment comments = 1;
inline int CommentList::comments_size() const {
  return comments_.size();
}
inline void CommentList::clear_comments() {
  comments_.Clear();
}
inline const ::ProtocolBuffer::Comment& CommentList::comments(int index) const {
  return comments_.Get(index);
}
inline ::ProtocolBuffer::Comment* CommentList::mutable_comments(int index) {
  return comments_.Mutable(index);
}
inline ::ProtocolBuffer::Comment* CommentList::add_comments() {
  return comments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Comment >&
CommentList::comments() const {
  return comments_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::Comment >*
CommentList::mutable_comments() {
  return &comments_;
}

// -------------------------------------------------------------------

// UserList

// repeated .ProtocolBuffer.User users = 1;
inline int UserList::users_size() const {
  return users_.size();
}
inline void UserList::clear_users() {
  users_.Clear();
}
inline const ::ProtocolBuffer::User& UserList::users(int index) const {
  return users_.Get(index);
}
inline ::ProtocolBuffer::User* UserList::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::ProtocolBuffer::User* UserList::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::User >&
UserList::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtocolBuffer::User >*
UserList::mutable_users() {
  return &users_;
}

// -------------------------------------------------------------------

// RestaurantType

// required uint32 TID = 1;
inline bool RestaurantType::has_tid() const {
  return _has_bit(0);
}
inline void RestaurantType::clear_tid() {
  tid_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 RestaurantType::tid() const {
  return tid_;
}
inline void RestaurantType::set_tid(::google::protobuf::uint32 value) {
  _set_bit(0);
  tid_ = value;
}

// required string name = 2;
inline bool RestaurantType::has_name() const {
  return _has_bit(1);
}
inline void RestaurantType::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RestaurantType::name() const {
  return *name_;
}
inline void RestaurantType::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RestaurantType::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RestaurantType::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RestaurantType::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// SearchResult

// optional .ProtocolBuffer.RestaurantList restaurants = 1;
inline bool SearchResult::has_restaurants() const {
  return _has_bit(0);
}
inline void SearchResult::clear_restaurants() {
  if (restaurants_ != NULL) restaurants_->::ProtocolBuffer::RestaurantList::Clear();
  _clear_bit(0);
}
inline const ::ProtocolBuffer::RestaurantList& SearchResult::restaurants() const {
  return restaurants_ != NULL ? *restaurants_ : *default_instance_->restaurants_;
}
inline ::ProtocolBuffer::RestaurantList* SearchResult::mutable_restaurants() {
  _set_bit(0);
  if (restaurants_ == NULL) restaurants_ = new ::ProtocolBuffer::RestaurantList;
  return restaurants_;
}

// optional .ProtocolBuffer.UserList users = 2;
inline bool SearchResult::has_users() const {
  return _has_bit(1);
}
inline void SearchResult::clear_users() {
  if (users_ != NULL) users_->::ProtocolBuffer::UserList::Clear();
  _clear_bit(1);
}
inline const ::ProtocolBuffer::UserList& SearchResult::users() const {
  return users_ != NULL ? *users_ : *default_instance_->users_;
}
inline ::ProtocolBuffer::UserList* SearchResult::mutable_users() {
  _set_bit(1);
  if (users_ == NULL) users_ = new ::ProtocolBuffer::UserList;
  return users_;
}

// -------------------------------------------------------------------

// Query

// optional .ProtocolBuffer.Area area = 1;
inline bool Query::has_area() const {
  return _has_bit(0);
}
inline void Query::clear_area() {
  if (area_ != NULL) area_->::ProtocolBuffer::Area::Clear();
  _clear_bit(0);
}
inline const ::ProtocolBuffer::Area& Query::area() const {
  return area_ != NULL ? *area_ : *default_instance_->area_;
}
inline ::ProtocolBuffer::Area* Query::mutable_area() {
  _set_bit(0);
  if (area_ == NULL) area_ = new ::ProtocolBuffer::Area;
  return area_;
}

// optional uint32 level = 2;
inline bool Query::has_level() const {
  return _has_bit(1);
}
inline void Query::clear_level() {
  level_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 Query::level() const {
  return level_;
}
inline void Query::set_level(::google::protobuf::uint32 value) {
  _set_bit(1);
  level_ = value;
}

// optional .ProtocolBuffer.Time time = 3;
inline bool Query::has_time() const {
  return _has_bit(2);
}
inline void Query::clear_time() {
  if (time_ != NULL) time_->::ProtocolBuffer::Time::Clear();
  _clear_bit(2);
}
inline const ::ProtocolBuffer::Time& Query::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::ProtocolBuffer::Time* Query::mutable_time() {
  _set_bit(2);
  if (time_ == NULL) time_ = new ::ProtocolBuffer::Time;
  return time_;
}

// optional uint32 RID = 4;
inline bool Query::has_rid() const {
  return _has_bit(3);
}
inline void Query::clear_rid() {
  rid_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 Query::rid() const {
  return rid_;
}
inline void Query::set_rid(::google::protobuf::uint32 value) {
  _set_bit(3);
  rid_ = value;
}

// optional uint32 UID = 5;
inline bool Query::has_uid() const {
  return _has_bit(4);
}
inline void Query::clear_uid() {
  uid_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 Query::uid() const {
  return uid_;
}
inline void Query::set_uid(::google::protobuf::uint32 value) {
  _set_bit(4);
  uid_ = value;
}

// optional uint32 n = 6;
inline bool Query::has_n() const {
  return _has_bit(5);
}
inline void Query::clear_n() {
  n_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 Query::n() const {
  return n_;
}
inline void Query::set_n(::google::protobuf::uint32 value) {
  _set_bit(5);
  n_ = value;
}

// optional uint32 UID_Target = 13;
inline bool Query::has_uid_target() const {
  return _has_bit(6);
}
inline void Query::clear_uid_target() {
  uid_target_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 Query::uid_target() const {
  return uid_target_;
}
inline void Query::set_uid_target(::google::protobuf::uint32 value) {
  _set_bit(6);
  uid_target_ = value;
}

// optional uint32 relation = 12;
inline bool Query::has_relation() const {
  return _has_bit(7);
}
inline void Query::clear_relation() {
  relation_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 Query::relation() const {
  return relation_;
}
inline void Query::set_relation(::google::protobuf::uint32 value) {
  _set_bit(7);
  relation_ = value;
}

// optional string msg = 7;
inline bool Query::has_msg() const {
  return _has_bit(8);
}
inline void Query::clear_msg() {
  if (msg_ != &_default_msg_) {
    msg_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& Query::msg() const {
  return *msg_;
}
inline void Query::set_msg(const ::std::string& value) {
  _set_bit(8);
  if (msg_ == &_default_msg_) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void Query::set_msg(const char* value) {
  _set_bit(8);
  if (msg_ == &_default_msg_) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void Query::set_msg(const char* value, size_t size) {
  _set_bit(8);
  if (msg_ == &_default_msg_) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_msg() {
  _set_bit(8);
  if (msg_ == &_default_msg_) {
    msg_ = new ::std::string;
  }
  return msg_;
}

// optional bytes image = 8;
inline bool Query::has_image() const {
  return _has_bit(9);
}
inline void Query::clear_image() {
  if (image_ != &_default_image_) {
    image_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& Query::image() const {
  return *image_;
}
inline void Query::set_image(const ::std::string& value) {
  _set_bit(9);
  if (image_ == &_default_image_) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void Query::set_image(const char* value) {
  _set_bit(9);
  if (image_ == &_default_image_) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void Query::set_image(const void* value, size_t size) {
  _set_bit(9);
  if (image_ == &_default_image_) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_image() {
  _set_bit(9);
  if (image_ == &_default_image_) {
    image_ = new ::std::string;
  }
  return image_;
}

// optional string emailAddress = 9;
inline bool Query::has_emailaddress() const {
  return _has_bit(10);
}
inline void Query::clear_emailaddress() {
  if (emailaddress_ != &_default_emailaddress_) {
    emailaddress_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& Query::emailaddress() const {
  return *emailaddress_;
}
inline void Query::set_emailaddress(const ::std::string& value) {
  _set_bit(10);
  if (emailaddress_ == &_default_emailaddress_) {
    emailaddress_ = new ::std::string;
  }
  emailaddress_->assign(value);
}
inline void Query::set_emailaddress(const char* value) {
  _set_bit(10);
  if (emailaddress_ == &_default_emailaddress_) {
    emailaddress_ = new ::std::string;
  }
  emailaddress_->assign(value);
}
inline void Query::set_emailaddress(const char* value, size_t size) {
  _set_bit(10);
  if (emailaddress_ == &_default_emailaddress_) {
    emailaddress_ = new ::std::string;
  }
  emailaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_emailaddress() {
  _set_bit(10);
  if (emailaddress_ == &_default_emailaddress_) {
    emailaddress_ = new ::std::string;
  }
  return emailaddress_;
}

// optional string password = 10;
inline bool Query::has_password() const {
  return _has_bit(11);
}
inline void Query::clear_password() {
  if (password_ != &_default_password_) {
    password_->clear();
  }
  _clear_bit(11);
}
inline const ::std::string& Query::password() const {
  return *password_;
}
inline void Query::set_password(const ::std::string& value) {
  _set_bit(11);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Query::set_password(const char* value) {
  _set_bit(11);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Query::set_password(const char* value, size_t size) {
  _set_bit(11);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_password() {
  _set_bit(11);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  return password_;
}

// optional .ProtocolBuffer.User userinfo = 11;
inline bool Query::has_userinfo() const {
  return _has_bit(12);
}
inline void Query::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::ProtocolBuffer::User::Clear();
  _clear_bit(12);
}
inline const ::ProtocolBuffer::User& Query::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::ProtocolBuffer::User* Query::mutable_userinfo() {
  _set_bit(12);
  if (userinfo_ == NULL) userinfo_ = new ::ProtocolBuffer::User;
  return userinfo_;
}

// optional .ProtocolBuffer.Location location = 14;
inline bool Query::has_location() const {
  return _has_bit(13);
}
inline void Query::clear_location() {
  if (location_ != NULL) location_->::ProtocolBuffer::Location::Clear();
  _clear_bit(13);
}
inline const ::ProtocolBuffer::Location& Query::location() const {
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::ProtocolBuffer::Location* Query::mutable_location() {
  _set_bit(13);
  if (location_ == NULL) location_ = new ::ProtocolBuffer::Location;
  return location_;
}

// optional string name = 15;
inline bool Query::has_name() const {
  return _has_bit(14);
}
inline void Query::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(14);
}
inline const ::std::string& Query::name() const {
  return *name_;
}
inline void Query::set_name(const ::std::string& value) {
  _set_bit(14);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Query::set_name(const char* value) {
  _set_bit(14);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Query::set_name(const char* value, size_t size) {
  _set_bit(14);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_name() {
  _set_bit(14);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// DMessage

// required uint32 fromUser = 1;
inline bool DMessage::has_fromuser() const {
  return _has_bit(0);
}
inline void DMessage::clear_fromuser() {
  fromuser_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 DMessage::fromuser() const {
  return fromuser_;
}
inline void DMessage::set_fromuser(::google::protobuf::uint32 value) {
  _set_bit(0);
  fromuser_ = value;
}

// required uint32 toUser = 2;
inline bool DMessage::has_touser() const {
  return _has_bit(1);
}
inline void DMessage::clear_touser() {
  touser_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 DMessage::touser() const {
  return touser_;
}
inline void DMessage::set_touser(::google::protobuf::uint32 value) {
  _set_bit(1);
  touser_ = value;
}

// required uint32 msgID = 6;
inline bool DMessage::has_msgid() const {
  return _has_bit(2);
}
inline void DMessage::clear_msgid() {
  msgid_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 DMessage::msgid() const {
  return msgid_;
}
inline void DMessage::set_msgid(::google::protobuf::uint32 value) {
  _set_bit(2);
  msgid_ = value;
}

// required bool isSystemMessage = 7;
inline bool DMessage::has_issystemmessage() const {
  return _has_bit(3);
}
inline void DMessage::clear_issystemmessage() {
  issystemmessage_ = false;
  _clear_bit(3);
}
inline bool DMessage::issystemmessage() const {
  return issystemmessage_;
}
inline void DMessage::set_issystemmessage(bool value) {
  _set_bit(3);
  issystemmessage_ = value;
}

// optional string text = 3;
inline bool DMessage::has_text() const {
  return _has_bit(4);
}
inline void DMessage::clear_text() {
  if (text_ != &_default_text_) {
    text_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& DMessage::text() const {
  return *text_;
}
inline void DMessage::set_text(const ::std::string& value) {
  _set_bit(4);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void DMessage::set_text(const char* value) {
  _set_bit(4);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void DMessage::set_text(const char* value, size_t size) {
  _set_bit(4);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DMessage::mutable_text() {
  _set_bit(4);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  return text_;
}

// optional .ProtocolBuffer.SystemMessageType systemMessageType = 4;
inline bool DMessage::has_systemmessagetype() const {
  return _has_bit(5);
}
inline void DMessage::clear_systemmessagetype() {
  systemmessagetype_ = 1;
  _clear_bit(5);
}
inline ProtocolBuffer::SystemMessageType DMessage::systemmessagetype() const {
  return static_cast< ProtocolBuffer::SystemMessageType >(systemmessagetype_);
}
inline void DMessage::set_systemmessagetype(ProtocolBuffer::SystemMessageType value) {
  GOOGLE_DCHECK(ProtocolBuffer::SystemMessageType_IsValid(value));
  _set_bit(5);
  systemmessagetype_ = value;
}

// optional string buffer = 5;
inline bool DMessage::has_buffer() const {
  return _has_bit(6);
}
inline void DMessage::clear_buffer() {
  if (buffer_ != &_default_buffer_) {
    buffer_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& DMessage::buffer() const {
  return *buffer_;
}
inline void DMessage::set_buffer(const ::std::string& value) {
  _set_bit(6);
  if (buffer_ == &_default_buffer_) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void DMessage::set_buffer(const char* value) {
  _set_bit(6);
  if (buffer_ == &_default_buffer_) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(value);
}
inline void DMessage::set_buffer(const char* value, size_t size) {
  _set_bit(6);
  if (buffer_ == &_default_buffer_) {
    buffer_ = new ::std::string;
  }
  buffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DMessage::mutable_buffer() {
  _set_bit(6);
  if (buffer_ == &_default_buffer_) {
    buffer_ = new ::std::string;
  }
  return buffer_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtocolBuffer

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MapProtocol_2eproto__INCLUDED
